<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ShuttleWinners by Rana</title>
<style>
/* ================== CSS ================== */
*{margin:0;padding:0;box-sizing:border-box;}
body{font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;background:linear-gradient(135deg,#1a1a1a 0%,#4a0000 100%);min-height:100vh;}
.container{display:flex;min-height:100vh;}
.menu-toggle{display:none;position:fixed;top:15px;left:15px;z-index:1001;background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);color:white;border:none;padding:12px 15px;border-radius:8px;cursor:pointer;font-size:20px;box-shadow:0 4px 15px rgba(196,30,58,0.4);}
.sidebar{width:250px;background:rgba(20,20,20,0.95);backdrop-filter:blur(10px);box-shadow:2px 0 20px rgba(196,30,58,0.3);padding:20px;transition:transform 0.3s ease;border-right:2px solid #c41e3a;}
.logo{text-align:center;margin-bottom:30px;padding-bottom:20px;border-bottom:2px solid #c41e3a;display:flex;flex-direction:column;align-items:center;gap:8px;}
.logo-icon{font-size:48px;margin-bottom:8px;animation:float 3s ease-in-out infinite;display:inline-block;}
@keyframes float{0%,100%{transform:translateY(0px);}50%{transform:translateY(-8px);}}
.logo h1{color:#c41e3a;font-size:26px;margin:0;font-weight:700;letter-spacing:1px;text-shadow:0 0 15px rgba(196,30,58,0.6),0 2px 4px rgba(0,0,0,0.3);}
.logo .copyright{color:#999;font-size:11px;font-style:italic;margin-top:2px;opacity:0.8;letter-spacing:0.5px;}
.menu-item{padding:15px 20px;margin:10px 0;border-radius:10px;cursor:pointer;transition:all 0.3s ease;display:flex;align-items:center;gap:10px;color:#ddd;border:1px solid transparent;}
.menu-item:hover{background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);color:white;transform:translateX(5px);border-color:#c41e3a;box-shadow:0 4px 15px rgba(196,30,58,0.3);}
.menu-item.active{background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);color:white;border-color:#c41e3a;box-shadow:0 4px 15px rgba(196,30,58,0.3);}
.menu-item.disabled{opacity:0.5;cursor:not-allowed;pointer-events:none;}
.menu-item.disabled:hover{background:rgba(20,20,20,0.95);color:#999;transform:none;border-color:transparent;box-shadow:none;}
.main-content{flex:1;padding:30px;overflow-y:auto;}
.content-section{display:none;animation:fadeIn 0.5s ease;}
.content-section.active{display:block;}
@keyframes fadeIn{from{opacity:0;transform:translateY(20px);}to{opacity:1;transform:translateY(0);}}
.card{background:rgba(20,20,20,0.9);border-radius:15px;padding:25px;margin-bottom:20px;box-shadow:0 5px 20px rgba(0,0,0,0.5);border:1px solid #c41e3a;}
.card h2{color:#c41e3a;margin-bottom:20px;font-size:28px;text-shadow:0 0 10px rgba(196,30,58,0.3);}
.tabs-container{display:flex;gap:10px;margin-bottom:25px;flex-wrap:wrap;}
.tab{padding:12px 20px;border-radius:8px;cursor:pointer;background:rgba(40,40,40,0.8);color:#ddd;font-weight:600;transition:all 0.3s ease;border:1px solid #333;flex:1;min-width:120px;text-align:center;}
.tab:hover{background:rgba(60,60,60,0.9);border-color:#c41e3a;}
.tab.active{background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);color:white;transform:scale(1.05);border-color:#c41e3a;box-shadow:0 4px 15px rgba(196,30,58,0.4);}
.tab-content{display:none;}
.tab-content.active{display:block;animation:fadeIn 0.4s ease;}
.fixture-table{width:100%;border-collapse:collapse;margin-top:15px;}
.fixture-table th,.fixture-table td{padding:15px;text-align:left;border-bottom:1px solid #333;color:#ddd;}
.fixture-table th{background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);color:white;font-weight:600;}
.fixture-table tr:hover{background:rgba(196,30,58,0.1);}
.vs-badge{display:inline-block;background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);color:white;padding:5px 15px;border-radius:20px;font-weight:bold;font-size:12px;box-shadow:0 2px 8px rgba(196,30,58,0.3);}
.ranking-table{width:100%;border-collapse:collapse;margin-top:15px;}
.ranking-table th,.ranking-table td{padding:15px;text-align:left;border-bottom:1px solid #333;color:#ddd;}
.ranking-table th{background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);color:white;font-weight:600;}
.rank-badge{display:inline-flex;align-items:center;justify-content:center;width:35px;height:35px;border-radius:50%;font-weight:bold;color:white;}
.rank-1{background:linear-gradient(135deg,#FFD700,#FFA500);box-shadow:0 0 15px rgba(255,215,0,0.5);}
.rank-2{background:linear-gradient(135deg,#C0C0C0,#A8A8A8);}
.rank-3{background:linear-gradient(135deg,#CD7F32,#B8860B);}
.rank-other{background:linear-gradient(135deg,#c41e3a,#8b0000);}
.form-group{margin-bottom:20px;}
.form-group label{display:block;margin-bottom:8px;color:#ddd;font-weight:600;}
.form-group input,.form-group select{width:100%;padding:12px 15px;border:2px solid #333;border-radius:8px;font-size:14px;background:rgba(40,40,40,0.8);color:#ddd;}
.form-group input:focus,.form-group select:focus{outline:none;border-color:#c41e3a;box-shadow:0 0 10px rgba(196,30,58,0.3);}
.btn{padding:12px 30px;border:none;border-radius:8px;font-size:16px;font-weight:600;cursor:pointer;transition:all 0.3s ease;}
.btn-primary{background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);color:white;box-shadow:0 4px 15px rgba(196,30,58,0.3);}
.btn-primary:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgba(196,30,58,0.5);}
.btn-success{background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);color:white;}
.btn-reset{background:linear-gradient(135deg,#666 0%,#444 100%);color:white;padding:12px 20px;border:none;border-radius:8px;font-size:14px;font-weight:600;cursor:pointer;transition:all 0.3s ease;margin-left:5px;}
.btn-reset:hover{background:linear-gradient(135deg,#888 0%,#666 100%);transform:translateY(-2px);box-shadow:0 4px 10px rgba(0,0,0,0.3);}
.modal{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:1000;align-items:center;justify-content:center;}
.modal.active{display:flex;}
.modal-content{background:rgba(20,20,20,0.95);padding:40px;border-radius:15px;width:90%;max-width:400px;box-shadow:0 10px 40px rgba(196,30,58,0.5);border:2px solid #c41e3a;}
.modal-content h2{color:#c41e3a;margin-bottom:25px;}
.notification{position:fixed;top:20px;right:20px;padding:15px 25px;border-radius:8px;color:white;font-weight:600;z-index:2000;animation:slideIn 0.3s ease;box-shadow:0 5px 20px rgba(0,0,0,0.5);}
.notification.success{background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);}
.notification.error{background:linear-gradient(135deg,#8b0000 0%,#4a0000 100%);}
@keyframes slideIn{from{transform:translateX(400px);opacity:0;}to{transform:translateX(0);opacity:1;}}
.admin-only{display:none;}
.score-input{width:60px;padding:8px;border:2px solid #333;border-radius:5px;text-align:center;background:rgba(40,40,40,0.8);color:#ddd;}
.edit-btn,.delete-btn{padding:8px 15px;margin:0 5px;border:none;border-radius:5px;cursor:pointer;font-size:12px;font-weight:600;}
.edit-btn{background:#c41e3a;color:white;}
.delete-btn{background:#8b0000;color:white;}
.no-matches{text-align:center;padding:40px;color:#999;font-style:italic;}
@media(max-width:768px){.menu-toggle{display:block;}.sidebar{position:fixed;left:-250px;top:0;height:100vh;z-index:100;}.sidebar.mobile-open{transform:translateX(250px);}.main-content{padding:70px 15px 15px 15px;}.card{padding:15px;}.card h2{font-size:22px;}.tabs-container{gap:5px;}.tab{padding:10px 12px;font-size:13px;min-width:80px;}.fixture-table th,.fixture-table td{padding:10px 5px;font-size:13px;}.ranking-table th,.ranking-table td{padding:10px 8px;font-size:13px;}.form-group input,.form-group select{font-size:16px;}.modal-content{padding:25px;width:95%;}}
@media(max-width:480px){.logo h1{font-size:20px;}.logo-icon{font-size:40px;}.logo .copyright{font-size:10px;}.tab{padding:8px 10px;font-size:12px;min-width:70px;}.vs-badge{padding:4px 10px;font-size:10px;}}
</style>
</head>
<body>
<button class="menu-toggle" onclick="toggleMenu()">‚ò∞</button>
<div class="container">
  <div class="sidebar" id="sidebar">
    <div class="logo">
      <div class="logo-icon">üè∏</div>
      <h1>ShuttleWinners</h1>
      <p class="copyright">Copyright ¬© By Rana</p>
    </div>
    <div class="menu-item active" onclick="goToSection('fixture')">üìã Fixture</div>
    <div class="menu-item" onclick="goToSection('ranking')">üèÜ Ranking</div>
    <div class="menu-item" id="adminLoginBtn" onclick="openLogin()">üîê Admin Login</div>
    <div class="menu-item admin-only" onclick="goToSection('manage-matches')">‚öîÔ∏è Update Scores</div>
    <div class="menu-item admin-only" onclick="goToSection('manage-teams')">üë• Manage Teams</div>
    <div class="menu-item admin-only" onclick="goToSection('manage-fixtures')">üìÖ Manage Fixtures</div>
    <div class="menu-item admin-only" onclick="doLogout()">üö™ Logout</div>
  </div>
  <div class="main-content">
    <div class="content-section active" id="fixture">
      <div class="card">
        <h2>Tournament Fixtures</h2>
        <div class="tabs-container">
          <div class="tab active" onclick="switchDay(1)">Day 1</div>
          <div class="tab" onclick="switchDay(2)">Day 2</div>
          <div class="tab" onclick="switchDay(3)">Day 3</div>
          <div class="tab" onclick="switchDay(4)">Final</div>
        </div>
        <div class="tab-content active" id="day-1">
          <table class="fixture-table">
            <thead><tr><th>Match</th><th>Team 1</th><th></th><th>Team 2</th><th>Score</th></tr></thead>
            <tbody id="day1Body"></tbody>
          </table>
        </div>
        <div class="tab-content" id="day-2">
          <table class="fixture-table">
            <thead><tr><th>Match</th><th>Team 1</th><th></th><th>Team 2</th><th>Score</th></tr></thead>
            <tbody id="day2Body"></tbody>
          </table>
        </div>
        <div class="tab-content" id="day-3">
          <table class="fixture-table">
            <thead><tr><th>Match</th><th>Team 1</th><th></th><th>Team 2</th><th>Score</th></tr></thead>
            <tbody id="day3Body"></tbody>
          </table>
        </div>
        <div class="tab-content" id="day-4">
          <table class="fixture-table">
            <thead><tr><th>Match</th><th>Team 1</th><th></th><th>Team 2</th><th>Score</th></tr></thead>
            <tbody id="day4Body"></tbody>
          </table>
        </div>
      </div>
    </div>
    <div class="content-section" id="ranking">
      <div class="card">
        <h2>Team Rankings</h2>
        <table class="ranking-table">
          <thead><tr><th>Rank</th><th>Team</th><th>P</th><th>W</th><th>L</th><th>Pts</th></tr></thead>
          <tbody id="rankingBody"></tbody>
        </table>
      </div>
    </div>
    <div class="content-section admin-only" id="manage-matches">
      <div class="card">
        <h2>Update Scores</h2>
        <div id="matchScores"></div>
      </div>
    </div>
    <div class="content-section admin-only" id="manage-teams">
      <div class="card">
        <h2>Manage Teams</h2>
        <div style="margin-bottom:30px;">
          <h3 style="color:#c41e3a;margin-bottom:15px;">Add New Team</h3>
          <form id="addTeamForm" onsubmit="event.preventDefault(); addNewTeam();">
            <div class="form-group">
              <label>Team Name</label>
              <input type="text" id="newTeamName" required placeholder="e.g., Sandip Smashers">
            </div>
            <div class="form-group">
              <label>Team Icon (Emoji)</label>
              <input type="text" id="newTeamIcon" required placeholder="e.g., üè∏" maxlength="2">
            </div>
            <button type="submit" class="btn btn-primary">Add Team</button>
          </form>
        </div>
        <div>
          <h3 style="color:#c41e3a;margin-bottom:15px;">Existing Teams</h3>
          <div id="teamsList"></div>
        </div>
      </div>
    </div>
    <div class="content-section admin-only" id="manage-fixtures">
      <div class="card">
        <h2>Manage Fixtures</h2>
        <div style="margin-bottom:30px;">
          <h3 style="color:#c41e3a;margin-bottom:15px;">Add New Match</h3>
          <form id="addMatchForm" onsubmit="event.preventDefault(); addNewMatch();">
            <div class="form-group">
              <label>Day</label>
              <select id="newMatchDay" required>
                <option value="1">Day 1</option>
                <option value="2">Day 2</option>
                <option value="3">Day 3</option>
                <option value="4">Day 4 (Final)</option>
              </select>
            </div>
            <div class="form-group">
              <label>Match Number (0 for Final)</label>
              <input type="number" id="newMatchNum" required min="0" placeholder="e.g., 1, 2, 3... or 0 for Final">
            </div>
            <div class="form-group">
              <label>Team 1</label>
              <select id="newMatchT1" required></select>
            </div>
            <div class="form-group">
              <label>Team 2</label>
              <select id="newMatchT2" required></select>
            </div>
            <div class="form-group">
              <label>Match Type</label>
              <select id="newMatchType" required>
                <option value="league">League</option>
                <option value="final">Final</option>
              </select>
            </div>
            <button type="submit" class="btn btn-primary">Add Match</button>
          </form>
        </div>
        <div>
          <h3 style="color:#c41e3a;margin-bottom:15px;">Existing Matches</h3>
          <div id="matchesList"></div>
        </div>
      </div>
    </div>
  </div>
</div>
<div class="modal" id="loginModal">
  <div class="modal-content">
    <h2>Admin Login</h2>
    <form id="loginForm" onsubmit="event.preventDefault(); loginAdmin();">
      <div class="form-group">
        <label>Username (Email)</label>
        <input type="email" id="username" required>
      </div>
      <div class="form-group">
        <label>Password</label>
        <input type="password" id="password" required>
      </div>
      <button type="submit" class="btn btn-primary" style="width:100%">Login</button>
      <button type="button" class="btn" style="width:100%;margin-top:10px;background:#333;color:#ddd" onclick="closeLogin()">Cancel</button>
    </form>
  </div>
</div>
<script type="module">
// ================== Supabase Configuration ==================
const SUPABASE_URL = 'https://ygyynxtuqgagcygqdmpu.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlneXlueHR1cWdhZ2N5Z3FkbXB1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjcwMDQyMzAsImV4cCI6MjA4MjU4MDIzMH0.epkP1_RVfLMCAFG33aekLmO0wrEDZQEBRyREXiKs1Os';

// Import Supabase JS Client
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// ================== Global Variables ==================
let isAdmin = false;
let teamsMap = {};

// ================== Load Teams ==================
async function loadTeamsMap() {
  const { data, error } = await supabase
    .from('teams')
    .select('*');
 
  if(error){
    console.error('Error loading teams:', error);
    return;
  }
 
  teamsMap = {};
  if(data){
    data.forEach(team => {
      teamsMap[team.name] = team;
    });
  }
}

// ================== Admin Authentication ==================
// Simple password-based authentication (no Supabase Auth needed)
const ADMIN_EMAIL = 'guharoytirthankar@gmail.com';
const ADMIN_PASSWORD = 'admin123'; // Change this to your preferred password

window.loginAdmin = async function(){
  const email = document.getElementById('username').value;
  const password = document.getElementById('password').value;
 
  // Simple password check
  if(email === ADMIN_EMAIL && password === ADMIN_PASSWORD){
    isAdmin = true;
    document.querySelectorAll('.admin-only').forEach(el => el.style.display = 'block');
   
    // Disable admin login button
    const adminLoginBtn = document.getElementById('adminLoginBtn');
    if(adminLoginBtn){
      adminLoginBtn.classList.add('disabled');
      adminLoginBtn.textContent = 'üîê Admin (Logged In)';
    }
   
    notify('Admin login successful!');
    closeLogin();
    document.getElementById('loginForm').reset();
  } else {
    notify('Invalid credentials', 'error');
  }
}

window.doLogout = function(){
  isAdmin = false;
  document.querySelectorAll('.admin-only').forEach(el => el.style.display = 'none');
 
  // Re-enable admin login button
  const adminLoginBtn = document.getElementById('adminLoginBtn');
  if(adminLoginBtn){
    adminLoginBtn.classList.remove('disabled');
    adminLoginBtn.textContent = 'üîê Admin Login';
  }
 
  notify('Logged out');
  goToSection('fixture');
}

// ================== UI Functions ==================
window.notify = function(msg, type = 'success'){
  const n = document.createElement('div');
  n.className = 'notification ' + type;
  n.textContent = msg;
  document.body.appendChild(n);
  setTimeout(() => n.remove(), 3000);
}

window.toggleMenu = function(){
  document.getElementById('sidebar').classList.toggle('mobile-open');
}

window.goToSection = function(id){
  document.querySelectorAll('.content-section').forEach(s => s.classList.remove('active'));
  document.querySelectorAll('.menu-item').forEach(m => m.classList.remove('active'));
  document.getElementById(id).classList.add('active');
  if(event && event.target) event.target.classList.add('active');
  if(window.innerWidth <= 768) document.getElementById('sidebar').classList.remove('mobile-open');
 
  if(id === 'fixture') loadFixtures();
  if(id === 'ranking') loadRankings();
  if(id === 'manage-matches') loadMatches();
  if(id === 'manage-teams') {
    loadTeamsList();
    populateTeamDropdowns();
  }
  if(id === 'manage-fixtures') {
    loadMatchesList();
    populateTeamDropdowns();
  }
}

window.switchDay = async function(d){
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
  if(event && event.target) event.target.classList.add('active');
  document.getElementById('day-' + d).classList.add('active');
 
  // Auto-update final match when viewing Day 4
  if(d === 4){
    await updateFinalMatch();
    await loadDay(4);
  }
}

window.openLogin = function(){
  document.getElementById('loginModal').classList.add('active');
}

window.closeLogin = function(){
  document.getElementById('loginModal').classList.remove('active');
}

// ================== Fixtures ==================
window.loadFixtures = async function(){
  for(let d = 1; d <= 4; d++) await loadDay(d);
}

async function loadDay(d){
  const tbody = document.getElementById('day' + d + 'Body');
  if(!tbody) {
    console.error('Table body not found for day:', d);
    return;
  }
 
  const { data, error } = await supabase
    .from('matches')
    .select('*')
    .eq('day', d)
    .order('num', { ascending: true });
 
  let html = '';
 
  if(error){
    console.error('Error loading matches for day', d, ':', error);
    html = `<tr><td colspan="5" class="no-matches">Error: ${error.message}</td></tr>`;
  } else if(data && data.length > 0){
    console.log('Loaded matches for day', d, ':', data);
    data.forEach(m => {
      const team1 = teamsMap[m.t1] || {name: m.t1, icon: 'üè∏'};
      const team2 = teamsMap[m.t2] || {name: m.t2, icon: 'üè∏'};
     
      let score = '- -';
      if(m.s1 !== null && m.s1 !== undefined && m.s2 !== null && m.s2 !== undefined){
        score = `${m.s1} - ${m.s2}`;
      }
     
      const matchLabel = m.type === 'final' || m.num === 0 ? 'FINAL' : 'Match ' + m.num;
     
      html += `<tr>
        <td>${matchLabel}</td>
        <td>${team1.icon} ${team1.name}</td>
        <td><span class="vs-badge">VS</span></td>
        <td>${team2.icon} ${team2.name}</td>
        <td>${score}</td>
      </tr>`;
    });
  }
 
  if(!html) html = '<tr><td colspan="5" class="no-matches">No matches</td></tr>';
  tbody.innerHTML = html;
}

// ================== Rankings - Real-time from Supabase ==================
let rankingsChannel = null;
let rankingsPollInterval = null;

window.loadRankings = async function(){
  const rBody = document.getElementById('rankingBody');
 
  // Try to subscribe to real-time changes
  try {
    rankingsChannel = supabase
      .channel('rankings-changes')
      .on('postgres_changes',
        { event: '*', schema: 'public', table: 'rankings' },
        (payload) => {
          console.log('Realtime update received:', payload);
          displayRankings();
        }
      )
      .subscribe((status) => {
        console.log('Realtime subscription status:', status);
        // If subscription fails, use polling as fallback
        if(status === 'SUBSCRIBED'){
          // Clear any existing polling
          if(rankingsPollInterval) clearInterval(rankingsPollInterval);
        } else {
          // Fallback to polling every 2 seconds
          if(!rankingsPollInterval){
            rankingsPollInterval = setInterval(() => {
              displayRankings();
            }, 2000);
          }
        }
      });
  } catch(error) {
    console.log('Realtime not available, using polling:', error);
    // Fallback to polling
    if(!rankingsPollInterval){
      rankingsPollInterval = setInterval(() => {
        displayRankings();
      }, 2000);
    }
  }
 
  // Initial load
  await displayRankings();
}

async function displayRankings(){
  const rBody = document.getElementById('rankingBody');
 
  const { data, error } = await supabase
    .from('rankings')
    .select('*')
    .order('pts', { ascending: false })
    .order('w', { ascending: false });
 
  if(error){
    console.error('Error loading rankings:', error);
    rBody.innerHTML = '<tr><td colspan="6" class="no-matches">Error loading rankings</td></tr>';
    return;
  }
 
  let html = '';
  if(!data || data.length === 0){
    html = '<tr><td colspan="6" class="no-matches">No teams registered yet</td></tr>';
  } else {
    data.forEach((t, i) => {
      const c = i === 0 ? 'rank-1' : i === 1 ? 'rank-2' : i === 2 ? 'rank-3' : 'rank-other';
      html += `<tr>
        <td><span class="rank-badge ${c}">${i + 1}</span></td>
        <td>${t.icon} ${t.name}</td>
        <td>${t.p || 0}</td>
        <td>${t.w || 0}</td>
        <td>${t.l || 0}</td>
        <td>${t.pts || 0}</td>
      </tr>`;
    });
  }
  rBody.innerHTML = html;
 
  // Auto-update final match when rankings are displayed
  await updateFinalMatch();
}

// ================== Calculate and Update Rankings ==================
async function calculateAndUpdateRankings(){
  console.log('Starting ranking calculation...');
 
  // Get all league matches with scores
  const { data: matches, error: matchesError } = await supabase
    .from('matches')
    .select('*')
    .eq('type', 'league')
    .not('s1', 'is', null)
    .not('s2', 'is', null);
 
  if(matchesError){
    console.error('Error loading matches:', matchesError);
    notify('Error loading matches: ' + matchesError.message, 'error');
    return;
  }
 
  console.log('Matches with scores:', matches);
 
  // Get all teams
  const { data: teams, error: teamsError } = await supabase.from('teams').select('*');
 
  if(teamsError){
    console.error('Error loading teams:', teamsError);
    notify('Error loading teams: ' + teamsError.message, 'error');
    return;
  }
 
  if(!teams || teams.length === 0){
    console.error('No teams found');
    return;
  }
 
  console.log('Teams loaded:', teams);
 
  // Initialize rankings
  const rankings = {};
  teams.forEach(team => {
    rankings[team.name] = {
      name: team.name,
      icon: team.icon,
      p: 0,
      w: 0,
      l: 0,
      pts: 0
    };
  });
 
  // Process matches (only those with valid scores)
  if(matches && matches.length > 0){
    matches.forEach(m => {
      // Double-check that scores are valid (not null/undefined)
      if(m.s1 === null || m.s1 === undefined || m.s2 === null || m.s2 === undefined){
        console.log('Skipping match with null scores:', m.t1, 'vs', m.t2);
        return; // Skip this match
      }
     
      console.log('Processing match:', m.t1, 'vs', m.t2, 'Score:', m.s1, '-', m.s2);
      if(rankings[m.t1] && rankings[m.t2]){
        rankings[m.t1].p++;
        rankings[m.t2].p++;
       
        if(m.s1 > m.s2){
          rankings[m.t1].w++;
          rankings[m.t1].pts += 2;
          rankings[m.t2].l++;
        } else if(m.s2 > m.s1){
          rankings[m.t2].w++;
          rankings[m.t2].pts += 2;
          rankings[m.t1].l++;
        }
        // Note: If scores are equal, both teams get a match played but no win/loss/points
      } else {
        console.warn('Team not found in rankings:', m.t1, 'or', m.t2);
      }
    });
  } else {
    console.log('No matches with scores found');
  }
 
  console.log('Calculated rankings:', rankings);
 
  // Update rankings in Supabase
  const updatePromises = [];
  for(const [teamName, stats] of Object.entries(rankings)){
    updatePromises.push(
      supabase
        .from('rankings')
        .upsert({
          name: teamName,
          icon: stats.icon,
          p: stats.p,
          w: stats.w,
          l: stats.l,
          pts: stats.pts
        }, { onConflict: 'name' })
    );
  }
 
  const results = await Promise.all(updatePromises);
  results.forEach((result, index) => {
    if(result.error) {
      console.error('Error updating ranking for:', Object.keys(rankings)[index], result.error);
    } else {
      console.log('Updated ranking for:', Object.keys(rankings)[index]);
    }
  });
 
  console.log('Rankings calculation complete');
 
  // Auto-update final match with top 2 teams
  await updateFinalMatch();
}

// ================== Auto-Update Final Match ==================
async function updateFinalMatch(){
  // First, check if all league matches (days 1-3) have been completed
  const { data: allLeagueMatches, error: matchesError } = await supabase
    .from('matches')
    .select('*')
    .eq('type', 'league')
    .in('day', [1, 2, 3]);
 
  if(matchesError){
    console.error('Error checking league matches:', matchesError);
    return;
  }
 
  if(!allLeagueMatches || allLeagueMatches.length === 0){
    console.log('No league matches found, cannot determine final teams yet');
    return;
  }
 
  // Check if all league matches have scores
  const incompleteMatches = allLeagueMatches.filter(m =>
    m.s1 === null || m.s1 === undefined || m.s2 === null || m.s2 === undefined
  );
 
  if(incompleteMatches.length > 0){
    console.log(`Not all league matches completed. ${incompleteMatches.length} match(es) still pending. Final teams will be determined after all league matches are played.`);
   
    // Check if final match exists
    const { data: existingFinal } = await supabase
      .from('matches')
      .select('*')
      .eq('day', 4)
      .eq('type', 'final')
      .maybeSingle();
   
    // If final match doesn't exist, create it with placeholder teams
    if(!existingFinal){
      const { error: createError } = await supabase
        .from('matches')
        .insert([{
          day: 4,
          num: 0,
          t1: 'Top 1 team',
          t2: 'Top 2 team',
          type: 'final',
          s1: null,
          s2: null
        }]);
     
      if(createError){
        console.error('Error creating placeholder final match:', createError);
      } else {
        console.log('Created final match with placeholder teams');
        // Refresh fixtures if on final tab
        if(document.getElementById('day-4') && document.getElementById('day-4').classList.contains('active')){
          loadDay(4);
        }
      }
      return;
    }
   
    // If final match exists but has real teams (not placeholders), reset to placeholder
    if(existingFinal.t1 !== 'Top 1 team' && existingFinal.t2 !== 'Top 2 team' &&
       existingFinal.s1 === null && existingFinal.s2 === null){
      await supabase
        .from('matches')
        .update({
          t1: 'Top 1 team',
          t2: 'Top 2 team'
        })
        .eq('id', existingFinal.id);
     
      console.log('Reset final match to placeholder teams (league not complete)');
      // Refresh fixtures if on final tab
      if(document.getElementById('day-4') && document.getElementById('day-4').classList.contains('active')){
        loadDay(4);
      }
    }
   
    return;
  }
 
  console.log('All league matches completed! Determining final teams...');
 
  // Get top 2 teams from rankings
  const { data: rankings, error: rankingsError } = await supabase
    .from('rankings')
    .select('*')
    .order('pts', { ascending: false })
    .order('w', { ascending: false })
    .limit(2);
 
  if(rankingsError){
    console.error('Error loading rankings for final:', rankingsError);
    return;
  }
 
  if(!rankings || rankings.length < 2){
    console.log('Not enough teams in rankings for final match');
    return;
  }
 
  const topTeam1 = rankings[0].name;
  const topTeam2 = rankings[1].name;
 
  console.log('Top 2 teams for final:', topTeam1, 'vs', topTeam2);
 
  // Find or create final match
  const { data: existingFinal, error: findError } = await supabase
    .from('matches')
    .select('*')
    .eq('day', 4)
    .eq('type', 'final')
    .maybeSingle();
 
  if(findError && findError.code !== 'PGRST116'){ // PGRST116 = no rows returned
    console.error('Error finding final match:', findError);
    return;
  }
 
  if(existingFinal){
    // Don't update if match has already been played (has scores)
    if(existingFinal.s1 !== null && existingFinal.s1 !== undefined &&
       existingFinal.s2 !== null && existingFinal.s2 !== undefined){
      console.log('Final match already played, not updating teams');
      return;
    }
   
    // Update existing final match (only if teams changed)
    if(existingFinal.t1 !== topTeam1 || existingFinal.t2 !== topTeam2){
      const { error: updateError } = await supabase
        .from('matches')
        .update({
          t1: topTeam1,
          t2: topTeam2
        })
        .eq('id', existingFinal.id);
     
      if(updateError){
        console.error('Error updating final match:', updateError);
      } else {
        console.log('Final match updated with top 2 teams');
        // Refresh fixtures if on final tab
        if(document.getElementById('day-4') && document.getElementById('day-4').classList.contains('active')){
          loadDay(4);
        }
      }
    } else {
      console.log('Final match teams already correct');
    }
  } else {
    // Create final match if it doesn't exist
    const { error: insertError } = await supabase
      .from('matches')
      .insert([{
        day: 4,
        num: 0,
        t1: topTeam1,
        t2: topTeam2,
        type: 'final',
        s1: null,
        s2: null
      }]);
   
    if(insertError){
      console.error('Error creating final match:', insertError);
    } else {
      console.log('Final match created with top 2 teams');
      // Refresh fixtures if on final tab
      if(document.getElementById('day-4') && document.getElementById('day-4').classList.contains('active')){
        loadDay(4);
      }
    }
  }
}

// ================== Matches Management ==================
window.loadMatches = async function(){
  const matchScoresDiv = document.getElementById('matchScores');
  matchScoresDiv.innerHTML = '';
 
  const { data, error } = await supabase
    .from('matches')
    .select('*')
    .eq('type', 'league')
    .order('day', { ascending: true })
    .order('num', { ascending: true });
 
  if(error){
    console.error('Error loading matches:', error);
    return;
  }
 
  if(data){
    data.forEach(m => {
      const team1 = teamsMap[m.t1] || {name: m.t1, icon: 'üè∏'};
      const team2 = teamsMap[m.t2] || {name: m.t2, icon: 'üè∏'};
      const s1 = m.s1 !== null && m.s1 !== undefined ? m.s1 : '';
      const s2 = m.s2 !== null && m.s2 !== undefined ? m.s2 : '';
      const matchLabel = m.num === 0 ? 'FINAL' : 'Match ' + m.num;
      matchScoresDiv.innerHTML += `<div style="margin-bottom:15px;padding:15px;background:rgba(40,40,40,0.5);border-radius:8px;">
        <strong>${matchLabel} (Day ${m.day}):</strong><br>
        ${team1.icon} ${team1.name}
        <input class="score-input" id="s1_${m.id}" value="${s1}" placeholder="0"> -
        <input class="score-input" id="s2_${m.id}" value="${s2}" placeholder="0">
        ${team2.icon} ${team2.name}
        <button class="btn btn-success" onclick="updateScore(${m.id})" style="margin-left:10px;">Update</button>
        <button class="btn-reset" onclick="resetScore(${m.id})">Reset</button>
      </div>`;
    });
  }
}

window.updateScore = async function(matchId){
  if(!isAdmin) {
    notify('Not authorized', 'error');
    return;
  }
 
  const s1Input = document.getElementById('s1_' + matchId);
  const s2Input = document.getElementById('s2_' + matchId);
 
  if(!s1Input || !s2Input){
    notify('Score inputs not found', 'error');
    console.error('Inputs not found for matchId:', matchId);
    return;
  }
 
  const s1 = parseInt(s1Input.value) || 0;
  const s2 = parseInt(s2Input.value) || 0;
 
  console.log('Updating score for match:', matchId, 'Score:', s1, '-', s2);
 
  const { data, error } = await supabase
    .from('matches')
    .update({ s1, s2 })
    .eq('id', matchId)
    .select();
 
  if(error){
    notify('Error updating score: ' + error.message, 'error');
    console.error('Update error:', error);
    return;
  }
 
  console.log('Score updated successfully:', data);
  notify('Score updated - Ranking will update automatically!');
 
  // Recalculate rankings immediately
  console.log('Recalculating rankings...');
  await calculateAndUpdateRankings();
 
  // Also refresh the ranking display
  await displayRankings();
 
  // Refresh fixtures to show updated scores
  loadFixtures();
 
  // Reload matches section to show updated scores
  loadMatches();
}

window.resetScore = async function(matchId){
  if(!isAdmin) {
    notify('Not authorized', 'error');
    return;
  }
 
  // Confirm reset
  if(!confirm('Are you sure you want to reset this score? This will remove the scores and recalculate rankings (matches played, wins, losses, and points will decrease).')){
    return;
  }
 
  console.log('Resetting score for match:', matchId);
 
  // Clear the input fields first (for immediate UI feedback)
  const s1Input = document.getElementById('s1_' + matchId);
  const s2Input = document.getElementById('s2_' + matchId);
  if(s1Input) s1Input.value = '';
  if(s2Input) s2Input.value = '';
 
  // Update database
  const { data, error } = await supabase
    .from('matches')
    .update({ s1: null, s2: null })
    .eq('id', matchId)
    .select();
 
  if(error){
    notify('Error resetting score: ' + error.message, 'error');
    console.error('Reset error:', error);
    // Reload matches to restore original values
    loadMatches();
    return;
  }
 
  console.log('Score reset successfully in database:', data);
  notify('Score reset - Recalculating rankings...');
 
  // Wait a moment to ensure database update is committed
  await new Promise(resolve => setTimeout(resolve, 100));
 
  // Recalculate rankings immediately (this will exclude the reset match)
  console.log('Recalculating rankings after reset (match will be excluded)...');
  await calculateAndUpdateRankings();
 
  // Refresh the ranking display
  await displayRankings();
 
  // Refresh fixtures to show updated scores
  loadFixtures();
 
  // Reload matches section to show updated scores
  loadMatches();
 
  notify('Score reset complete - Rankings updated!', 'success');
}

// ================== Team Management ==================
window.loadTeamsList = async function(){
  const teamsListDiv = document.getElementById('teamsList');
  if(!teamsListDiv) return;
 
  const { data: teams, error } = await supabase
    .from('teams')
    .select('*')
    .order('name', { ascending: true });
 
  if(error){
    console.error('Error loading teams:', error);
    teamsListDiv.innerHTML = '<p style="color:#c41e3a;">Error loading teams</p>';
    return;
  }
 
  if(!teams || teams.length === 0){
    teamsListDiv.innerHTML = '<p style="color:#999;">No teams found</p>';
    return;
  }
 
  let html = '<div style="display:grid;gap:15px;">';
  teams.forEach(team => {
    html += `<div style="padding:15px;background:rgba(40,40,40,0.5);border-radius:8px;display:flex;justify-content:space-between;align-items:center;">
      <div>
        <strong style="color:#ddd;font-size:18px;">${team.icon} ${team.name}</strong>
      </div>
      <button class="delete-btn" onclick="deleteTeam(${team.id}, '${team.name}')" style="padding:8px 15px;">Delete</button>
    </div>`;
  });
  html += '</div>';
  teamsListDiv.innerHTML = html;
}

window.addNewTeam = async function(){
  if(!isAdmin) {
    notify('Not authorized', 'error');
    return;
  }
 
  const name = document.getElementById('newTeamName').value.trim();
  const icon = document.getElementById('newTeamIcon').value.trim();
 
  if(!name || !icon){
    notify('Please fill in all fields', 'error');
    return;
  }
 
  // Check if team already exists
  const { data: existing } = await supabase
    .from('teams')
    .select('*')
    .eq('name', name)
    .single();
 
  if(existing){
    notify('Team with this name already exists!', 'error');
    return;
  }
 
  const { data, error } = await supabase
    .from('teams')
    .insert([{ name, icon }])
    .select();
 
  if(error){
    notify('Error adding team: ' + error.message, 'error');
    console.error('Add team error:', error);
    return;
  }
 
  notify('Team added successfully!', 'success');
 
  // Clear form
  document.getElementById('newTeamName').value = '';
  document.getElementById('newTeamIcon').value = '';
 
  // Reload teams list and map
  await loadTeamsMap();
  await loadTeamsList();
 
  // Add team to rankings with zero stats
  await supabase
    .from('rankings')
    .upsert({
      name: name,
      icon: icon,
      p: 0,
      w: 0,
      l: 0,
      pts: 0
    }, { onConflict: 'name' });
 
  // Update team dropdowns in add match form
  populateTeamDropdowns();
 
  // Refresh rankings display
  await displayRankings();
}

window.deleteTeam = async function(teamId, teamName){
  if(!isAdmin) {
    notify('Not authorized', 'error');
    return;
  }
 
  if(!confirm(`Are you sure you want to delete "${teamName}"? This will also delete all matches involving this team and update rankings.`)){
    return;
  }
 
  // First, delete all matches involving this team
  const { error: matchesError } = await supabase
    .from('matches')
    .delete()
    .or(`t1.eq.${teamName},t2.eq.${teamName}`);
 
  if(matchesError){
    console.error('Error deleting matches:', matchesError);
  }
 
  // Delete rankings for this team
  const { error: rankingsError } = await supabase
    .from('rankings')
    .delete()
    .eq('name', teamName);
 
  if(rankingsError){
    console.error('Error deleting rankings:', rankingsError);
  }
 
  // Delete the team
  const { error } = await supabase
    .from('teams')
    .delete()
    .eq('id', teamId);
 
  if(error){
    notify('Error deleting team: ' + error.message, 'error');
    console.error('Delete team error:', error);
    return;
  }
 
  notify('Team deleted successfully!', 'success');
 
  // Reload everything
  await loadTeamsMap();
  await loadTeamsList();
  await loadFixtures();
  await loadMatches();
  await calculateAndUpdateRankings();
  await displayRankings();
  populateTeamDropdowns();
}

// ================== Match/Fixture Management ==================
window.loadMatchesList = async function(){
  const matchesListDiv = document.getElementById('matchesList');
  if(!matchesListDiv) return;
 
  const { data: matches, error } = await supabase
    .from('matches')
    .select('*')
    .order('day', { ascending: true })
    .order('num', { ascending: true });
 
  if(error){
    console.error('Error loading matches:', error);
    matchesListDiv.innerHTML = '<p style="color:#c41e3a;">Error loading matches</p>';
    return;
  }
 
  if(!matches || matches.length === 0){
    matchesListDiv.innerHTML = '<p style="color:#999;">No matches found</p>';
    return;
  }
 
  let html = '<div style="display:grid;gap:15px;">';
  matches.forEach(match => {
    const team1 = teamsMap[match.t1] || {name: match.t1, icon: 'üè∏'};
    const team2 = teamsMap[match.t2] || {name: match.t2, icon: 'üè∏'};
    const matchLabel = match.type === 'final' || match.num === 0 ? 'FINAL' : `Match ${match.num}`;
    const score = (match.s1 !== null && match.s2 !== null) ? `${match.s1} - ${match.s2}` : '- -';
   
    html += `<div style="padding:15px;background:rgba(40,40,40,0.5);border-radius:8px;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
        <div>
          <strong style="color:#c41e3a;">Day ${match.day} - ${matchLabel}</strong>
        </div>
        <button class="delete-btn" onclick="deleteMatch(${match.id})" style="padding:8px 15px;">Delete</button>
      </div>
      <div style="color:#ddd;">
        ${team1.icon} ${team1.name} <span style="margin:0 10px;">VS</span> ${team2.icon} ${team2.name}
        <span style="margin-left:15px;color:#999;">Score: ${score}</span>
      </div>
    </div>`;
  });
  html += '</div>';
  matchesListDiv.innerHTML = html;
}

function populateTeamDropdowns(){
  const t1Select = document.getElementById('newMatchT1');
  const t2Select = document.getElementById('newMatchT2');
 
  if(!t1Select || !t2Select) return;
 
  const teamNames = Object.keys(teamsMap).sort();
 
  t1Select.innerHTML = '<option value="">Select Team 1</option>';
  t2Select.innerHTML = '<option value="">Select Team 2</option>';
 
  teamNames.forEach(teamName => {
    const team = teamsMap[teamName];
    const option1 = `<option value="${teamName}">${team.icon} ${team.name}</option>`;
    const option2 = `<option value="${teamName}">${team.icon} ${team.name}</option>`;
    t1Select.innerHTML += option1;
    t2Select.innerHTML += option2;
  });
}

window.addNewMatch = async function(){
  if(!isAdmin) {
    notify('Not authorized', 'error');
    return;
  }
 
  const day = parseInt(document.getElementById('newMatchDay').value);
  const num = parseInt(document.getElementById('newMatchNum').value);
  const t1 = document.getElementById('newMatchT1').value;
  const t2 = document.getElementById('newMatchT2').value;
  const type = document.getElementById('newMatchType').value;
 
  if(!t1 || !t2){
    notify('Please select both teams', 'error');
    return;
  }
 
  if(t1 === t2){
    notify('Team 1 and Team 2 cannot be the same!', 'error');
    return;
  }
 
  // Check if match already exists
  const { data: existing } = await supabase
    .from('matches')
    .select('*')
    .eq('day', day)
    .eq('num', num)
    .eq('t1', t1)
    .eq('t2', t2)
    .single();
 
  if(existing){
    notify('This match already exists!', 'error');
    return;
  }
 
  const { data, error } = await supabase
    .from('matches')
    .insert([{ day, num, t1, t2, type, s1: null, s2: null }])
    .select();
 
  if(error){
    notify('Error adding match: ' + error.message, 'error');
    console.error('Add match error:', error);
    return;
  }
 
  notify('Match added successfully!', 'success');
 
  // Clear form
  document.getElementById('newMatchNum').value = '';
  document.getElementById('newMatchT1').value = '';
  document.getElementById('newMatchT2').value = '';
 
  // Reload matches list and fixtures
  await loadMatchesList();
  await loadFixtures();
  await loadMatches();
}

window.deleteMatch = async function(matchId){
  if(!isAdmin) {
    notify('Not authorized', 'error');
    return;
  }
 
  if(!confirm('Are you sure you want to delete this match? This will also remove its score from rankings.')){
    return;
  }
 
  const { error } = await supabase
    .from('matches')
    .delete()
    .eq('id', matchId);
 
  if(error){
    notify('Error deleting match: ' + error.message, 'error');
    console.error('Delete match error:', error);
    return;
  }
 
  notify('Match deleted successfully!', 'success');
 
  // Recalculate rankings
  await calculateAndUpdateRankings();
  await displayRankings();
 
  // Reload everything
  await loadMatchesList();
  await loadFixtures();
  await loadMatches();
}

// ================== Initialize App ==================
window.addEventListener('load', async () => {
  await loadTeamsMap();
 
  // Set up real-time listener for matches (to recalculate rankings)
  try {
    supabase
      .channel('matches-changes')
      .on('postgres_changes',
        { event: 'UPDATE', schema: 'public', table: 'matches' },
        (payload) => {
          console.log('Match updated, recalculating rankings:', payload);
          calculateAndUpdateRankings();
        }
      )
      .subscribe((status) => {
        console.log('Matches subscription status:', status);
        // If realtime doesn't work, we'll recalculate on manual refresh
      });
  } catch(error) {
    console.log('Realtime for matches not available:', error);
  }
 
  // Initialize rankings if they don't exist
  const { data } = await supabase.from('rankings').select('count');
  if(!data || data.length === 0){
    await calculateAndUpdateRankings();
  }
 
  goToSection('fixture');
});
</script>
</body>
</html>
