style="color:#c41e3a;">Day 4</strong></li>
              <li>Final teams are automatically updated in the system once all league matches are completed</li>
            </ul>
            <p style="color:#ddd;margin-top:15px;padding:15px;background:rgba(196,30,58,0.2);border-radius:8px;border-left:3px solid #c41e3a;">
              <strong style="color:#c41e3a;">Note:</strong> Until all league matches are completed, the Final will show "Top 1 team" vs "Top 2 team" as placeholders.
            </p>
          </div>
        </div>
       
        <div style="margin-bottom:30px;">
          <h3 style="color:#c41e3a;margin-bottom:15px;font-size:24px;">‚öñÔ∏è Tie-Breaking Rules</h3>
          <div style="background:rgba(40,40,40,0.5);padding:20px;border-radius:10px;margin-bottom:20px;">
            <h4 style="color:#c41e3a;margin-bottom:10px;">When teams have the same points:</h4>
            <ol style="color:#ddd;line-height:1.8;padding-left:20px;">
              <li><strong style="color:#c41e3a;">Point Difference (PD):</strong> Team with higher PD ranks higher</li>
              <li><strong style="color:#c41e3a;">Wins (W):</strong> If PD is equal, team with more wins ranks higher</li>
              <li><strong style="color:#c41e3a;">Head-to-Head:</strong> If still tied, result of match between the two teams</li>
              <li><strong style="color:#c41e3a;">Alphabetical:</strong> Final tiebreaker by team name</li>
            </ol>
            <p style="color:#ddd;margin-top:15px;padding:15px;background:rgba(196,30,58,0.2);border-radius:8px;border-left:3px solid #c41e3a;">
              <strong style="color:#c41e3a;">Point Difference Calculation:</strong> For each match, PD = (Your Score - Opponent Score). Total PD is the sum of all match differences.
            </p>
          </div>
        </div>
       
        <div style="background:linear-gradient(135deg,rgba(196,30,58,0.2) 0%,rgba(139,0,0,0.2) 100%);padding:20px;border-radius:10px;border:2px solid #c41e3a;margin-top:30px;">
          <h4 style="color:#c41e3a;margin-bottom:10px;">üìù Important Notes:</h4>
          <ul style="color:#ddd;line-height:1.8;padding-left:20px;">
            <li>All matches must be completed for accurate rankings</li>
            <li>Rankings update automatically when scores are entered</li>
            <li>Final teams are determined only after all league matches are completed</li>
            <li>Incomplete matches do not count towards rankings</li>
            <li>Admin can reset all data to start a new season</li>
          </ul>
        </div>
      </div>
    </div>
    <div class="content-section admin-only" id="manage-matches">
      <div class="card">
        <h2>Update Scores</h2>
        <div id="matchScores"></div>
      </div>
      <div class="card" style="margin-top:20px;border:2px solid #8b0000;">
        <h2 style="color:#8b0000;">‚ö†Ô∏è Season Management</h2>
        window.loadRankings = async function(){
  const rBody = document.getElementById('rankingBody');
 
  // Try to subscribe to real-time changes
  try {
    rankingsChannel = supabase
      .channel('rankings-changes')
      .on('postgres_changes',
        { event: '*', schema: 'public', table: 'rankings' },
        (payload) => {
          console.log('Realtime update received:', payload);
          displayRankings();
        }
      )
      .subscribe((status) => {
        console.log('Realtime subscription status:', status);
        // If subscription fails, use polling as fallback
        if(status === 'SUBSCRIBED'){
          // Clear any existing polling
          if(rankingsPollInterval) clearInterval(rankingsPollInterval);
        } else {
          // Fallback to polling every 2 seconds
          if(!rankingsPollInterval){
            rankingsPollInterval = setInterval(() => {
              displayRankings();
            }, 2000);
          }
        }
      });
  } catch(error) {
    console.log('Realtime not available, using polling:', error);
    // Fallback to polling
    if(!rankingsPollInterval){
      rankingsPollInterval = setInterval(() => {
        displayRankings();
      }, 2000);
    }
  }
 
  // Initial load
  await displayRankings();
}

async function displayRankings(){
  const rBody = document.getElementById('rankingBody');
 
  const { data, error } = await supabase
    .from('rankings')
    .select('*');
 
  if(error){
    console.error('Error loading rankings:', error);
    rBody.innerHTML = '<tr><td colspan="7" class="no-matches">Error loading rankings</td></tr>';
    return;
  }
 
  let html = '';
  if(!data || data.length === 0){
    html = '<tr><td colspan="7" class="no-matches">No teams registered yet</td></tr>';
  } else {
    // Sort by points first, then by point difference if points are equal
    const sortedData = [...data].sort((a, b) => {
      // First sort by points (descending)
      if(b.pts !== a.pts) return b.pts - a.pts;
      // If points are equal, sort by point difference (descending)
      if(b.pd !== a.pd) return (b.pd || 0) - (a.pd || 0);
      // If both are equal, sort by wins (descending)
      if(b.w !== a.w) return b.w - a.w;
      // Finally, sort alphabetically by name
      return a.name.localeCompare(b.name);
    });
   
    sortedData.forEach((t, i) => {
      const c = i === 0 ? 'rank-1' : i === 1 ? 'rank-2' : i === 2 ? 'rank-3' : 'rank-other';
      const pd = t.pd || 0;
      const pdDisplay = pd > 0 ? `+${pd}` : pd.toString();
      html += `<tr>
        <td><span class="rank-badge ${c}">${i + 1}</span></td>
        <td>${t.icon} ${t.name}</td>
        <td>${t.p || 0}</td>
        <td>${t.w || 0}</td>
        <td>${t.l || 0}</td>
        <td style="color:${pd > 0 ? '#4CAF50' : pd < 0 ? '#f44336' : '#999'};">${pdDisplay}</td>
        <td>${t.pts || 0}</td>
      </tr>`;
    });
  }2</option>';
 
  teamNames.forEach(teamName => {
    const team = teamsMap[teamName];
    const option1 = `<option value="${teamName}">${team.icon} ${team.name}</option>`;
    const option2 = `<option value="${teamName}">${team.icon} ${team.name}</option>`;
    t1Select.innerHTML += option1;
    t2Select.innerHTML += option2;
  });
}

window.addNewMatch = async function(){
  if(!isAdmin) {
    notify('Not authorized', 'error');
    return;
  }
 
  const day = parseInt(document.getElementById('newMatchDay').value);
  const num = parseInt(document.getElementById('newMatchNum').value);
  const t1 = document.getElementById('newMatchT1').value;
  const t2 = document.getElementById('newMatchT2').value;
  const type = document.getElementById('newMatchType').value;
 
  if(!t1 || !t2){
    notify('Please select both teams', 'error');
    return;
  }
 
  if(t1 === t2){
    notify('Team 1 and Team 2 cannot be the same!', 'error');
    return;
  }
 
  // Check if match already exists
  const { data: existing } = await supabase
    .from('matches')
    .select('*')
    .eq('day', day)
    .eq('num', num)
    .eq('t1', t1)
    .eq('t2', t2)
    .single();
 
  if(existing){
    notify('This match already exists!', 'error');
    return;
  }
 
  const { data, error } = await supabase
    .from('matches')
    .insert([{ day, num, t1, t2, type, s1: null, s2: null }])
    .select();
 
  if(error){
    notify('Error adding match: ' + error.message, 'error');
    console.error('Add match error:', error);
    return;
  }
 
  notify('Match added successfully!', 'success');
 
  // Clear form
  document.getElementById('newMatchNum').value = '';
  document.getElementById('newMatchT1').value = '';
  document.getElementById('newMatchT2').value = '';
 
  // Reload matches list and fixtures
  await loadMatchesList();
  await loadFixtures();
  await loadMatches();
}

window.deleteMatch = async function(matchId){
  if(!isAdmin) {
    notify('Not authorized', 'error');
    return;
  }
 
  if(!confirm('Are you sure you want to delete this match? This will also remove its score from rankings.')){
    return;
  }
 
  const { error } = await supabase
    .from('matches')
    .delete()
    .eq('id', matchId);
 
  if(error){
    notify('Error deleting match: ' + error.message, 'error');
    console.error('Delete match error:', error);
    return;
  }notify('Match deleted successfully!', 'success');
 
  // Recalculate rankings
  await calculateAndUpdateRankings();
  await displayRankings();
 
  // Reload everything
  await loadMatchesList();
  await loadFixtures();
  await loadMatches();
}

// ================== Initialize App ==================
window.addEventListener('load', async () => {
  await loadTeamsMap();
 
  // Set up real-time listener for matches (to recalculate rankings)
  try {
    supabase
      .channel('matches-changes')
      .on('postgres_changes',
        { event: 'UPDATE', schema: 'public', table: 'matches' },
        (payload) => {
          console.log('Match updated, recalculating rankings:', payload);
          calculateAndUpdateRankings();
        }
      )
      .subscribe((status) => {
        console.log('Matches subscription status:', status);
        // If realtime doesn't work, we'll recalculate on manual refresh
      });
  } catch(error) {
    console.log('Realtime for matches not available:', error);
  }
 
  // Load rankings and calculate if needed
  await loadRankings();
 
  // Always calculate rankings on load to ensure they're up to date
  await calculateAndUpdateRankings();
 
  goToSection('fixture');
});
</script>
</body>
</html>
