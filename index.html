<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ShuttleWinners by Rana</title>
<style>
/* ================== CSS ================== */
*{margin:0;padding:0;box-sizing:border-box;}
body{font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;background:linear-gradient(135deg,#1a1a1a 0%,#4a0000 100%);min-height:100vh;position:relative;overflow-x:hidden;}
body::before{content:'';position:fixed;top:0;left:0;width:100%;height:100%;background-image:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(196,30,58,0.03) 2px,rgba(196,30,58,0.03) 4px),repeating-linear-gradient(90deg,transparent,transparent 2px,rgba(196,30,58,0.03) 2px,rgba(196,30,58,0.03) 4px);background-size:50px 50px;z-index:0;pointer-events:none;}
.bg-shuttlecocks{position:fixed;top:0;left:0;width:100%;height:100%;z-index:0;pointer-events:none;overflow:hidden;}
.badminton-player{position:absolute;bottom:5%;right:3%;width:250px;height:350px;opacity:0.12;animation:playBadminton 1.5s infinite ease-in-out;}
@keyframes playBadminton{0%{transform:translateY(0) scaleY(1);}25%{transform:translateY(-30px) scaleY(0.95);}50%{transform:translateY(-15px) scaleY(1);}75%{transform:translateY(-25px) scaleY(0.98);}100%{transform:translateY(0) scaleY(1);}}
.badminton-player svg{width:100%;height:100%;filter:drop-shadow(0 0 10px rgba(196,30,58,0.3));}
.container{display:flex;min-height:100vh;position:relative;z-index:1;}
.menu-toggle{display:none;position:fixed;top:15px;left:15px;z-index:1001;background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);color:white;border:none;padding:12px 15px;border-radius:8px;cursor:pointer;font-size:20px;box-shadow:0 4px 15px rgba(196,30,58,0.4);}
.sidebar{width:250px;background:rgba(20,20,20,0.95);backdrop-filter:blur(10px);box-shadow:2px 0 20px rgba(196,30,58,0.3);padding:20px;transition:transform 0.3s ease;border-right:2px solid #c41e3a;position:relative;z-index:1;}
.logo{text-align:center;margin-bottom:30px;padding-bottom:20px;border-bottom:2px solid #c41e3a;display:flex;flex-direction:column;align-items:center;gap:8px;}
.logo-icon{font-size:48px;margin-bottom:8px;animation:float 3s ease-in-out infinite;display:inline-block;}
@keyframes float{0%,100%{transform:translateY(0px);}50%{transform:translateY(-8px);}}
.logo h1{color:#c41e3a;font-size:26px;margin:0;font-weight:700;letter-spacing:1px;text-shadow:0 0 15px rgba(196,30,58,0.6),0 2px 4px rgba(0,0,0,0.3);}
.logo .copyright{color:#999;font-size:11px;font-style:italic;margin-top:2px;opacity:0.8;letter-spacing:0.5px;}
.menu-item{padding:15px 20px;margin:10px 0;border-radius:10px;cursor:pointer;transition:all 0.3s ease;display:flex;align-items:center;gap:10px;color:#ddd;border:1px solid transparent;}
.menu-item:hover{background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);color:white;transform:translateX(5px);border-color:#c41e3a;box-shadow:0 4px 15px rgba(196,30,58,0.3);}
.menu-item.active{background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);color:white;border-color:#c41e3a;box-shadow:0 4px 15px rgba(196,30,58,0.3);}
.menu-item.disabled{opacity:0.5;cursor:not-allowed;pointer-events:none;}
.menu-item.disabled:hover{background:rgba(20,20,20,0.95);color:#999;transform:none;border-color:transparent;box-shadow:none;}
.main-content{flex:1;padding:30px;overflow-y:auto;position:relative;z-index:1;}
.content-section{display:none;animation:fadeIn 0.5s ease;}
.content-section.active{display:block;}
@keyframes fadeIn{from{opacity:0;transform:translateY(20px);}to{opacity:1;transform:translateY(0);}}
.card{background:rgba(20,20,20,0.9);border-radius:15px;padding:25px;margin-bottom:20px;box-shadow:0 5px 20px rgba(0,0,0,0.5);border:1px solid #c41e3a;}
.card h2{color:#c41e3a;margin-bottom:20px;font-size:28px;text-shadow:0 0 10px rgba(196,30,58,0.3);}
.tabs-container{display:flex;gap:10px;margin-bottom:25px;flex-wrap:wrap;}
.tab{padding:12px 20px;border-radius:8px;cursor:pointer;background:rgba(40,40,40,0.8);color:#ddd;font-weight:600;transition:all 0.3s ease;border:1px solid #333;flex:1;min-width:120px;text-align:center;}
.tab:hover{background:rgba(60,60,60,0.9);border-color:#c41e3a;}
.tab.active{background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);color:white;transform:scale(1.05);border-color:#c41e3a;box-shadow:0 4px 15px rgba(196,30,58,0.4);}
.tab-content{display:none;}
.tab-content.active{display:block;animation:fadeIn 0.4s ease;}
.fixture-table{width:100%;border-collapse:collapse;margin-top:15px;}
.fixture-table th,.fixture-table td{padding:15px;text-align:left;border-bottom:1px solid #333;color:#ddd;}
.fixture-table th{background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);color:white;font-weight:600;}
.fixture-table tr:hover{background:rgba(196,30,58,0.1);}
.vs-badge{display:inline-block;background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);color:white;padding:5px 15px;border-radius:20px;font-weight:bold;font-size:12px;box-shadow:0 2px 8px rgba(196,30,58,0.3);}
.ranking-table{width:100%;border-collapse:collapse;margin-top:15px;}
.ranking-table th,.ranking-table td{padding:15px;text-align:left;border-bottom:1px solid #333;color:#ddd;}
.ranking-table th{background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);color:white;font-weight:600;}
.rank-badge{display:inline-flex;align-items:center;justify-content:center;width:35px;height:35px;border-radius:50%;font-weight:bold;color:white;}
.rank-1{background:linear-gradient(135deg,#FFD700,#FFA500);box-shadow:0 0 15px rgba(255,215,0,0.5);}
.rank-2{background:linear-gradient(135deg,#C0C0C0,#A8A8A8);}
.rank-3{background:linear-gradient(135deg,#CD7F32,#B8860B);}
.rank-other{background:linear-gradient(135deg,#c41e3a,#8b0000);}
.form-group{margin-bottom:20px;}
.form-group label{display:block;margin-bottom:8px;color:#ddd;font-weight:600;}
.form-group input,.form-group select{width:100%;padding:12px 15px;border:2px solid #333;border-radius:8px;font-size:14px;background:rgba(40,40,40,0.8);color:#ddd;}
.form-group input:focus,.form-group select:focus{outline:none;border-color:#c41e3a;box-shadow:0 0 10px rgba(196,30,58,0.3);}
.btn{padding:12px 30px;border:none;border-radius:8px;font-size:16px;font-weight:600;cursor:pointer;transition:all 0.3s ease;}
.btn-primary{background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);color:white;box-shadow:0 4px 15px rgba(196,30,58,0.3);}
.btn-primary:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgba(196,30,58,0.5);}
.btn-success{background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);color:white;}
.btn-reset{background:linear-gradient(135deg,#666 0%,#444 100%);color:white;padding:12px 20px;border:none;border-radius:8px;font-size:14px;font-weight:600;cursor:pointer;transition:all 0.3s ease;margin-left:5px;}
.btn-reset:hover{background:linear-gradient(135deg,#888 0%,#666 100%);transform:translateY(-2px);box-shadow:0 4px 10px rgba(0,0,0,0.3);}
.modal{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:1000;align-items:center;justify-content:center;}
.modal.active{display:flex;}
.modal-content{background:rgba(20,20,20,0.95);padding:40px;border-radius:15px;width:90%;max-width:400px;box-shadow:0 10px 40px rgba(196,30,58,0.5);border:2px solid #c41e3a;}
.modal-content h2{color:#c41e3a;margin-bottom:25px;}
.notification{position:fixed;top:20px;right:20px;padding:15px 25px;border-radius:8px;color:white;font-weight:600;z-index:2000;animation:slideIn 0.3s ease;box-shadow:0 5px 20px rgba(0,0,0,0.5);}
.notification.success{background:linear-gradient(135deg,#c41e3a 0%,#8b0000 100%);}
.notification.error{background:linear-gradient(135deg,#8b0000 0%,#4a0000 100%);}
@keyframes slideIn{from{transform:translateX(400px);opacity:0;}to{transform:translateX(0);opacity:1;}}
.winner-panel{position:fixed;top:0;right:-400px;width:400px;height:100vh;background:linear-gradient(135deg,#1a1a1a 0%,#4a0000 100%);z-index:2000;transition:right 0.5s ease;box-shadow:-5px 0 30px rgba(0,0,0,0.8);border-left:3px solid #c41e3a;}
.winner-panel.active{right:0;}
.winner-content{padding:40px 30px;text-align:center;height:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;position:relative;}
.winner-close{position:absolute;top:20px;right:20px;background:none;border:none;color:#ddd;font-size:36px;cursor:pointer;width:40px;height:40px;display:flex;align-items:center;justify-content:center;border-radius:50%;transition:all 0.3s ease;}
.winner-close:hover{background:rgba(196,30,58,0.3);color:#fff;transform:rotate(90deg);}
.winner-icon{font-size:80px;margin-bottom:20px;animation:bounce 1s ease infinite;}
@keyframes bounce{0%,100%{transform:translateY(0);}50%{transform:translateY(-20px);}}
.winner-title{color:#c41e3a;font-size:32px;margin-bottom:30px;text-shadow:0 0 20px rgba(196,30,58,0.8);font-weight:700;line-height:1.2;}
.winner-team{color:#fff;font-size:48px;font-weight:700;margin-bottom:20px;text-shadow:0 0 15px rgba(255,255,255,0.5);background:linear-gradient(135deg,#FFD700 0%,#FFA500 100%);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;animation:pulse 2s ease infinite;}
@keyframes pulse{0%,100%{transform:scale(1);}50%{transform:scale(1.05);}}
.winner-celebration{font-size:40px;margin-top:20px;animation:celebrate 1.5s ease infinite;}
@keyframes celebrate{0%,100%{transform:rotate(0deg) scale(1);}25%{transform:rotate(-10deg) scale(1.1);}75%{transform:rotate(10deg) scale(1.1);}}
.admin-only{display:none;}
.score-input{width:60px;padding:8px;border:2px solid #333;border-radius:5px;text-align:center;background:rgba(40,40,40,0.8);color:#ddd;}
.edit-btn,.delete-btn{padding:8px 15px;margin:0 5px;border:none;border-radius:5px;cursor:pointer;font-size:12px;font-weight:600;}
.edit-btn{background:#c41e3a;color:white;}
.delete-btn{background:#8b0000;color:white;}
.no-matches{text-align:center;padding:40px;color:#999;font-style:italic;}
@media(max-width:768px){.menu-toggle{display:block;}.sidebar{position:fixed;left:-250px;top:0;height:100vh;z-index:100;}.sidebar.mobile-open{transform:translateX(250px);}.main-content{padding:70px 15px 15px 15px;}.card{padding:15px;}.card h2{font-size:22px;}.tabs-container{gap:5px;}.tab{padding:10px 12px;font-size:13px;min-width:80px;}.fixture-table th,.fixture-table td{padding:10px 5px;font-size:13px;}.ranking-table th,.ranking-table td{padding:10px 8px;font-size:13px;}.form-group input,.form-group select{font-size:16px;}.modal-content{padding:25px;width:95%;}.winner-panel{width:100%;right:-100%;}.winner-title{font-size:24px;}.winner-team{font-size:36px;}.winner-icon{font-size:60px;}}
@media(max-width:480px){.logo h1{font-size:20px;}.logo-icon{font-size:40px;}.logo .copyright{font-size:10px;}.tab{padding:8px 10px;font-size:12px;min-width:70px;}.vs-badge{padding:4px 10px;font-size:10px;}}
</style>
</head>
<body>
<div class="bg-shuttlecocks">
  <div class="badminton-player">
    <svg viewBox="0 0 200 300" xmlns="http://www.w3.org/2000/svg">
      <!-- Badminton Player Silhouette -->
      <!-- Head -->
      <circle cx="100" cy="50" r="20" fill="#c41e3a" opacity="0.8"/>
     
      <!-- Body -->
      <rect x="85" y="70" width="30" height="80" rx="5" fill="#c41e3a" opacity="0.8"/>
     
      <!-- Left Arm (Racket Arm) -->
      <g id="racketArm">
        <ellipse cx="100" cy="90" rx="8" ry="25" fill="#c41e3a" opacity="0.8" transform="rotate(-45 100 90)"/>
        <!-- Racket -->
        <g transform="translate(60, 60)">
          <ellipse cx="0" cy="0" rx="25" ry="35" fill="#8b0000" opacity="0.9"/>
          <ellipse cx="0" cy="0" rx="20" ry="30" fill="none" stroke="#c41e3a" stroke-width="2" opacity="0.6"/>
          <!-- Racket strings -->
          <line x1="-20" y1="-25" x2="-20" y2="25" stroke="#c41e3a" stroke-width="1" opacity="0.5"/>
          <line x1="0" y1="-25" x2="0" y2="25" stroke="#c41e3a" stroke-width="1" opacity="0.5"/>
          <line x1="20" y1="-25" x2="20" y2="25" stroke="#c41e3a" stroke-width="1" opacity="0.5"/>
          <line x1="-25" y1="-15" x2="25" y2="-15" stroke="#c41e3a" stroke-width="1" opacity="0.5"/>
          <line x1="-25" y1="0" x2="25" y2="0" stroke="#c41e3a" stroke-width="1" opacity="0.5"/>
          <line x1="-25" y1="15" x2="25" y2="15" stroke="#c41e3a" stroke-width="1" opacity="0.5"/>
        </g>
        <animateTransform attributeName="transform" attributeType="XML" type="rotate" values="-45 100 90; -15 100 90; -45 100 90" dur="1.5s" repeatCount="indefinite"/>
      </g>
     
      <!-- Right Arm -->
      <ellipse cx="120" cy="100" rx="8" ry="30" fill="#c41e3a" opacity="0.8" transform="rotate(30 120 100)"/>
     
      <!-- Left Leg -->
      <ellipse cx="90" cy="180" rx="12" ry="50" fill="#c41e3a" opacity="0.8" transform="rotate(-10 90 180)"/>
      <ellipse cx="90" cy="220" rx="10" ry="30" fill="#8b0000" opacity="0.9"/>
     
      <!-- Right Leg -->
      <ellipse cx="110" cy="180" rx="12" ry="50" fill="#c41e3a" opacity="0.8" transform="rotate(10 110 180)"/>
      <ellipse cx="110" cy="220" rx="10" ry="30" fill="#8b0000" opacity="0.9"/>
     
      <!-- Shuttlecock -->
      <g id="shuttlecock">
        <circle cx="100" cy="200" r="8" fill="#fff" opacity="0.9"/>
        <path d="M 100 200 L 95 220 L 100 225 L 105 220 Z" fill="#fff" opacity="0.9"/>
        <path d="M 100 200 L 90 215 M 100 200 L 110 215" stroke="#fff" stroke-width="2" opacity="0.7"/>
        <animateTransform attributeName="transform" attributeType="XML" type="translate" values="0,0; 20,-30; 0,0" dur="1.5s" repeatCount="indefinite"/>
      </g>
    </svg>
  </div>
</div>
<button class="menu-toggle" onclick="toggleMenu()">‚ò∞</button>
<div class="container">
  <div class="sidebar" id="sidebar">
    <div class="logo">
      <div class="logo-icon">üè∏</div>
      <h1>ShuttleWinners</h1>
      <p class="copyright">Copyright ¬© By Rana</p>
    </div>
    <div class="menu-item active" onclick="goToSection('fixture')">üìã Fixture</div>
    <div class="menu-item" onclick="goToSection('ranking')">üèÜ Ranking</div>
    <div class="menu-item" onclick="goToSection('rules')">üìú Tournament Rules</div>
    <div class="menu-item" id="adminLoginBtn" onclick="openLogin()">üîê Admin Login</div>
    <div class="menu-item admin-only" onclick="goToSection('manage-matches')">‚öîÔ∏è Update Scores</div>
    <div class="menu-item admin-only" onclick="goToSection('manage-teams')">üë• Manage Teams</div>
    <div class="menu-item admin-only" onclick="goToSection('manage-fixtures')">üìÖ Manage Fixtures</div>
    <div class="menu-item admin-only" onclick="doLogout()">üö™ Logout</div>
  </div>
  <div class="main-content">
    <div class="content-section active" id="fixture">
      <div class="card">
        <h2>Tournament Fixtures</h2>
        <div class="tabs-container">
          <div class="tab active" onclick="switchDay(1)">Day 1</div>
          <div class="tab" onclick="switchDay(2)">Day 2</div>
          <div class="tab" onclick="switchDay(3)">Day 3</div>
          <div class="tab" onclick="switchDay(4)">Final</div>
        </div>
        <div class="tab-content active" id="day-1">
          <table class="fixture-table">
            <thead><tr><th>Match</th><th>Team 1</th><th></th><th>Team 2</th><th>Score</th></tr></thead>
            <tbody id="day1Body"></tbody>
          </table>
        </div>
        <div class="tab-content" id="day-2">
          <table class="fixture-table">
            <thead><tr><th>Match</th><th>Team 1</th><th></th><th>Team 2</th><th>Score</th></tr></thead>
            <tbody id="day2Body"></tbody>
          </table>
        </div>
        <div class="tab-content" id="day-3">
          <table class="fixture-table">
            <thead><tr><th>Match</th><th>Team 1</th><th></th><th>Team 2</th><th>Score</th></tr></thead>
            <tbody id="day3Body"></tbody>
          </table>
        </div>
        <div class="tab-content" id="day-4">
          <div id="winnerAnnouncement" style="display:none;margin-bottom:30px;">
            <div class="card" style="background:linear-gradient(135deg,rgba(196,30,58,0.3) 0%,rgba(139,0,0,0.3) 100%);border:3px solid #c41e3a;text-align:center;padding:40px;">
              <div style="font-size:60px;margin-bottom:20px;animation:bounce 1s ease infinite;">üèÜ</div>
              <h2 style="color:#c41e3a;font-size:36px;margin-bottom:15px;text-shadow:0 0 20px rgba(196,30,58,0.8);">Winner Winner Chicken Dinner!</h2>
              <div id="winnerTeamDisplay" style="color:#fff;font-size:48px;font-weight:700;margin-bottom:20px;text-shadow:0 0 15px rgba(255,255,255,0.5);background:linear-gradient(135deg,#FFD700 0%,#FFA500 100%);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;animation:pulse 2s ease infinite;"></div>
              <div style="font-size:40px;margin-top:20px;animation:celebrate 1.5s ease infinite;">üéâ üéä üéâ</div>
            </div>
          </div>
          <table class="fixture-table">
            <thead><tr><th>Match</th><th>Team 1</th><th></th><th>Team 2</th><th>Score</th></tr></thead>
            <tbody id="day4Body"></tbody>
          </table>
        </div>
      </div>
    </div>
    <div class="content-section" id="ranking">
      <div class="card">
        <h2>Team Rankings</h2>
        <table class="ranking-table">
          <thead><tr><th>Rank</th><th>Team</th><th>P</th><th>W</th><th>L</th><th>PD</th><th>Pts</th></tr></thead>
          <tbody id="rankingBody"></tbody>
        </table>
      </div>
    </div>
    <div class="content-section" id="rules">
      <div class="card">
        <h2>üìú Tournament Rules</h2>
       
        <div style="margin-bottom:30px;">
          <h3 style="color:#c41e3a;margin-bottom:15px;font-size:24px;">üè∏ Badminton Doubles Rules</h3>
          <div style="background:rgba(40,40,40,0.5);padding:20px;border-radius:10px;margin-bottom:20px;">
            <h4 style="color:#c41e3a;margin-bottom:10px;">Basic Rules:</h4>
            <ul style="color:#ddd;line-height:1.8;padding-left:20px;">
              <li>Each match is played as best of 3 games (first to win 2 games)</li>
              <li>Each game is played to 21 points</li>
              <li>A team must win by 2 points, or first to reach 30 points wins</li>
              <li>Teams switch sides after each game</li>
              <li>Service alternates between teams</li>
              <li>Only the serving team can score points</li>
              <li>If the serving team wins the rally, they score and continue serving</li>
              <li>If the receiving team wins the rally, they become the serving team</li>
            </ul>
          </div>
         
          <div style="background:rgba(40,40,40,0.5);padding:20px;border-radius:10px;margin-bottom:20px;">
            <h4 style="color:#c41e3a;margin-bottom:10px;">Scoring System:</h4>
            <ul style="color:#ddd;line-height:1.8;padding-left:20px;">
              <li>Games are played to 21 points</li>
              <li>Must win by 2 points (e.g., 21-19, 22-20)</li>
              <li>Maximum score is 30 points (e.g., 30-29)</li>
              <li>Match score is recorded as: Game 1 Score - Game 2 Score - Game 3 Score (if needed)</li>
            </ul>
          </div>
        </div>
       
        <div style="margin-bottom:30px;">
          <h3 style="color:#c41e3a;margin-bottom:15px;font-size:24px;">üèÜ Tournament Point System</h3>
          <div style="background:rgba(40,40,40,0.5);padding:20px;border-radius:10px;margin-bottom:20px;">
            <ul style="color:#ddd;line-height:1.8;padding-left:20px;">
              <li><strong style="color:#c41e3a;">Winner:</strong> Gets <strong>2 points</strong></li>
              <li><strong style="color:#c41e3a;">Loser:</strong> Gets <strong>0 points</strong></li>
              <li>Points are awarded only to the winning team of each match</li>
              <li>No points for draws or incomplete matches</li>
            </ul>
          </div>
        </div>
       
        <div style="margin-bottom:30px;">
          <h3 style="color:#c41e3a;margin-bottom:15px;font-size:24px;">üìä Ranking System</h3>
          <div style="background:rgba(40,40,40,0.5);padding:20px;border-radius:10px;margin-bottom:20px;">
            <h4 style="color:#c41e3a;margin-bottom:10px;">Rankings are determined by:</h4>
            <ol style="color:#ddd;line-height:1.8;padding-left:20px;">
              <li><strong style="color:#c41e3a;">Total Points (Pts):</strong> Primary ranking factor</li>
              <li><strong style="color:#c41e3a;">Point Difference (PD):</strong> If points are equal, teams are ranked by point difference (score_for - score_against)</li>
              <li><strong style="color:#c41e3a;">Wins (W):</strong> If points and PD are equal, teams are ranked by number of wins</li>
              <li><strong style="color:#c41e3a;">Alphabetical:</strong> Final tiebreaker if all above are equal</li>
            </ol>
            <p style="color:#ddd;margin-top:15px;padding:15px;background:rgba(196,30,58,0.2);border-radius:8px;border-left:3px solid #c41e3a;">
              <strong style="color:#c41e3a;">Example:</strong> If Team A and Team B both have 6 points, but Team A has +15 PD and Team B has +8 PD, Team A ranks higher.
            </p>
          </div>
        </div>
       
        <div style="margin-bottom:30px;">
          <h3 style="color:#c41e3a;margin-bottom:15px;font-size:24px;">üéØ Final Selection</h3>
          <div style="background:rgba(40,40,40,0.5);padding:20px;border-radius:10px;margin-bottom:20px;">
            <h4 style="color:#c41e3a;margin-bottom:10px;">How Teams are Selected for Finals:</h4>
            <ul style="color:#ddd;line-height:1.8;padding-left:20px;">
              <li>After <strong style="color:#c41e3a;">all league matches (Days 1-3)</strong> are completed</li>
              <li>The <strong style="color:#c41e3a;">top 2 teams</strong> from the rankings automatically qualify for the Final</li>
              <li>Ranking is determined by: Points ‚Üí Point Difference ‚Üí Wins</li>
              <li>The Final match will be played on <strong style="color:#c41e3a;">Day 4</strong></li>
              <li>Final teams are automatically updated in the system once all league matches are completed</li>
            </ul>
            <p style="color:#ddd;margin-top:15px;padding:15px;background:rgba(196,30,58,0.2);border-radius:8px;border-left:3px solid #c41e3a;">
              <strong style="color:#c41e3a;">Note:</strong> Until all league matches are completed, the Final will show "Top 1 team" vs "Top 2 team" as placeholders.
            </p>
          </div>
        </div>
       
        <div style="margin-bottom:30px;">
          <h3 style="color:#c41e3a;margin-bottom:15px;font-size:24px;">‚öñÔ∏è Tie-Breaking Rules</h3>
          <div style="background:rgba(40,40,40,0.5);padding:20px;border-radius:10px;margin-bottom:20px;">
            <h4 style="color:#c41e3a;margin-bottom:10px;">When teams have the same points:</h4>
            <ol style="color:#ddd;line-height:1.8;padding-left:20px;">
              <li><strong style="color:#c41e3a;">Point Difference (PD):</strong> Team with higher PD ranks higher</li>
              <li><strong style="color:#c41e3a;">Wins (W):</strong> If PD is equal, team with more wins ranks higher</li>
              <li><strong style="color:#c41e3a;">Head-to-Head:</strong> If still tied, result of match between the two teams</li>
              <li><strong style="color:#c41e3a;">Alphabetical:</strong> Final tiebreaker by team name</li>
            </ol>
            <p style="color:#ddd;margin-top:15px;padding:15px;background:rgba(196,30,58,0.2);border-radius:8px;border-left:3px solid #c41e3a;">
              <strong style="color:#c41e3a;">Point Difference Calculation:</strong> For each match, PD = (Your Score - Opponent Score). Total PD is the sum of all match differences.
            </p>
          </div>
        </div>
       
        <div style="background:linear-gradient(135deg,rgba(196,30,58,0.2) 0%,rgba(139,0,0,0.2) 100%);padding:20px;border-radius:10px;border:2px solid #c41e3a;margin-top:30px;">
          <h4 style="color:#c41e3a;margin-bottom:10px;">üìù Important Notes:</h4>
          <ul style="color:#ddd;line-height:1.8;padding-left:20px;">
            <li>All matches must be completed for accurate rankings</li>
            <li>Rankings update automatically when scores are entered</li>
            <li>Final teams are determined only after all league matches are completed</li>
            <li>Incomplete matches do not count towards rankings</li>
            <li>Admin can reset all data to start a new season</li>
          </ul>
        </div>
      </div>
    </div>
    <div class="content-section admin-only" id="manage-matches">
      <div class="card">
        <h2>Update Scores</h2>
        <div id="matchScores"></div>
      </div>
      <div class="card" style="margin-top:20px;border:2px solid #8b0000;">
        <h2 style="color:#8b0000;">‚ö†Ô∏è Season Management</h2>
        <p style="color:#ddd;margin-bottom:20px;">Reset all matches, scores, and rankings to start a new season. Teams will be preserved.</p>
        <button class="btn" onclick="resetAllData()" style="background:linear-gradient(135deg,#8b0000 0%,#4a0000 100%);color:white;padding:15px 30px;font-size:16px;">üîÑ All Reset</button>
      </div>
    </div>
    <div class="content-section admin-only" id="manage-teams">
      <div class="card">
        <h2>Manage Teams</h2>
        <div style="margin-bottom:30px;">
          <h3 style="color:#c41e3a;margin-bottom:15px;">Add New Team</h3>
          <form id="addTeamForm" onsubmit="event.preventDefault(); addNewTeam();">
            <div class="form-group">
              <label>Team Name</label>
              <input type="text" id="newTeamName" required placeholder="e.g., Sandip Smashers">
            </div>
            <div class="form-group">
              <label>Team Icon (Emoji)</label>
              <input type="text" id="newTeamIcon" required placeholder="e.g., üè∏" maxlength="2">
            </div>
            <button type="submit" class="btn btn-primary">Add Team</button>
          </form>
        </div>
        <div>
          <h3 style="color:#c41e3a;margin-bottom:15px;">Existing Teams</h3>
          <div id="teamsList"></div>
        </div>
      </div>
    </div>
    <div class="content-section admin-only" id="manage-fixtures">
      <div class="card">
        <h2>Manage Fixtures</h2>
        <div style="margin-bottom:30px;">
          <h3 style="color:#c41e3a;margin-bottom:15px;">Add New Match</h3>
          <form id="addMatchForm" onsubmit="event.preventDefault(); addNewMatch();">
            <div class="form-group">
              <label>Day</label>
              <select id="newMatchDay" required>
                <option value="1">Day 1</option>
                <option value="2">Day 2</option>
                <option value="3">Day 3</option>
                <option value="4">Day 4 (Final)</option>
              </select>
            </div>
            <div class="form-group">
              <label>Match Number (0 for Final)</label>
              <input type="number" id="newMatchNum" required min="0" placeholder="e.g., 1, 2, 3... or 0 for Final">
            </div>
            <div class="form-group">
              <label>Team 1</label>
              <select id="newMatchT1" required></select>
            </div>
            <div class="form-group">
              <label>Team 2</label>
              <select id="newMatchT2" required></select>
            </div>
            <div class="form-group">
              <label>Match Type</label>
              <select id="newMatchType" required>
                <option value="league">League</option>
                <option value="final">Final</option>
              </select>
            </div>
            <button type="submit" class="btn btn-primary">Add Match</button>
          </form>
        </div>
        <div>
          <h3 style="color:#c41e3a;margin-bottom:15px;">Existing Matches</h3>
          <div id="matchesList"></div>
        </div>
      </div>
    </div>
  </div>
</div>
<div class="winner-panel" id="winnerPanel">
  <div class="winner-content">
    <button class="winner-close" onclick="closeWinnerPanel()">√ó</button>
    <div class="winner-icon">üèÜ</div>
    <h2 class="winner-title">Winner Winner Chicken Dinner!</h2>
    <div class="winner-team" id="winnerTeamName"></div>
    <div class="winner-celebration">üéâ üéä üéâ</div>
  </div>
</div>
<div class="modal" id="loginModal">
  <div class="modal-content">
    <h2>Admin Login</h2>
    <form id="loginForm" onsubmit="event.preventDefault(); loginAdmin();">
      <div class="form-group">
        <label>Username (Email)</label>
        <input type="email" id="username" required>
      </div>
      <div class="form-group">
        <label>Password</label>
        <input type="password" id="password" required>
      </div>
      <button type="submit" class="btn btn-primary" style="width:100%">Login</button>
      <button type="button" class="btn" style="width:100%;margin-top:10px;background:#333;color:#ddd" onclick="closeLogin()">Cancel</button>
    </form>
  </div>
</div>
<script type="module">
// ================== Supabase Configuration ==================
const SUPABASE_URL = 'https://ygyynxtuqgagcygqdmpu.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlneXlueHR1cWdhZ2N5Z3FkbXB1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjcwMDQyMzAsImV4cCI6MjA4MjU4MDIzMH0.epkP1_RVfLMCAFG33aekLmO0wrEDZQEBRyREXiKs1Os';

// Import Supabase JS Client
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// ================== Global Variables ==================
let isAdmin = false;
let teamsMap = {};

// ================== Load Teams ==================
async function loadTeamsMap() {
  const { data, error } = await supabase
    .from('teams')
    .select('*');
 
  if(error){
    console.error('Error loading teams:', error);
    return;
  }
 
  teamsMap = {};
  if(data){
    data.forEach(team => {
      teamsMap[team.name] = team;
    });
  }
}

// ================== Admin Authentication ==================
// Simple password-based authentication (no Supabase Auth needed)
const ADMIN_EMAIL = 'guharoytirthankar@gmail.com';
const ADMIN_PASSWORD = 'admin123'; // Change this to your preferred password

window.loginAdmin = async function(){
  const email = document.getElementById('username').value;
  const password = document.getElementById('password').value;
 
  // Simple password check
  if(email === ADMIN_EMAIL && password === ADMIN_PASSWORD){
    isAdmin = true;
    document.querySelectorAll('.admin-only').forEach(el => el.style.display = 'block');
   
    // Disable admin login button
    const adminLoginBtn = document.getElementById('adminLoginBtn');
    if(adminLoginBtn){
      adminLoginBtn.classList.add('disabled');
      adminLoginBtn.textContent = 'üîê Admin (Logged In)';
    }
   
    notify('Admin login successful!');
    closeLogin();
    document.getElementById('loginForm').reset();
  } else {
    notify('Invalid credentials', 'error');
  }
}

window.doLogout = function(){
  isAdmin = false;
  document.querySelectorAll('.admin-only').forEach(el => el.style.display = 'none');
 
  // Re-enable admin login button
  const adminLoginBtn = document.getElementById('adminLoginBtn');
  if(adminLoginBtn){
    adminLoginBtn.classList.remove('disabled');
    adminLoginBtn.textContent = 'üîê Admin Login';
  }
 
  notify('Logged out');
  goToSection('fixture');
}

// ================== UI Functions ==================
window.notify = function(msg, type = 'success'){
  const n = document.createElement('div');
  n.className = 'notification ' + type;
  n.textContent = msg;
  document.body.appendChild(n);
  setTimeout(() => n.remove(), 3000);
}

window.showWinnerPanel = function(winnerTeamName){
  const winnerPanel = document.getElementById('winnerPanel');
  const winnerTeamNameEl = document.getElementById('winnerTeamName');
 
  if(winnerPanel && winnerTeamNameEl){
    // Get team icon if available
    const team = teamsMap[winnerTeamName] || {name: winnerTeamName, icon: 'üè∏'};
    winnerTeamNameEl.innerHTML = `${team.icon} ${team.name}`;
    winnerPanel.classList.add('active');
  }
}

window.closeWinnerPanel = function(){
  const winnerPanel = document.getElementById('winnerPanel');
  if(winnerPanel){
    winnerPanel.classList.remove('active');
  }
}

window.toggleMenu = function(){
  document.getElementById('sidebar').classList.toggle('mobile-open');
}

window.goToSection = function(id){
  document.querySelectorAll('.content-section').forEach(s => s.classList.remove('active'));
  document.querySelectorAll('.menu-item').forEach(m => m.classList.remove('active'));
  document.getElementById(id).classList.add('active');
  if(event && event.target) event.target.classList.add('active');
  if(window.innerWidth <= 768) document.getElementById('sidebar').classList.remove('mobile-open');
 
  if(id === 'fixture') loadFixtures();
  if(id === 'ranking') loadRankings();
  if(id === 'manage-matches') loadMatches();
  if(id === 'manage-teams') {
    loadTeamsList();
    populateTeamDropdowns();
  }
  if(id === 'manage-fixtures') {
    loadMatchesList();
    populateTeamDropdowns();
  }
}

window.switchDay = async function(d){
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
  if(event && event.target) event.target.classList.add('active');
  document.getElementById('day-' + d).classList.add('active');
 
  // Auto-update final match when viewing Day 4
  if(d === 4){
    await updateFinalMatch();
    await loadDay(4);
  }
}

window.openLogin = function(){
  document.getElementById('loginModal').classList.add('active');
}

window.closeLogin = function(){
  document.getElementById('loginModal').classList.remove('active');
}

// ================== Fixtures ==================
window.loadFixtures = async function(){
  for(let d = 1; d <= 4; d++) await loadDay(d);
}

async function loadDay(d){
  const tbody = document.getElementById('day' + d + 'Body');
  if(!tbody) {
    console.error('Table body not found for day:', d);
    return;
  }
 
  const { data, error } = await supabase
    .from('matches')
    .select('*')
    .eq('day', d)
    .order('num', { ascending: true });
 
  let html = '';
 
  if(error){
    console.error('Error loading matches for day', d, ':', error);
    html = `<tr><td colspan="5" class="no-matches">Error: ${error.message}</td></tr>`;
  } else if(data && data.length > 0){
    console.log('Loaded matches for day', d, ':', data);
    data.forEach(m => {
      const team1 = teamsMap[m.t1] || {name: m.t1, icon: 'üè∏'};
      const team2 = teamsMap[m.t2] || {name: m.t2, icon: 'üè∏'};
     
      let score = '- -';
      if(m.s1 !== null && m.s1 !== undefined && m.s2 !== null && m.s2 !== undefined){
        score = `${m.s1} - ${m.s2}`;
      }
     
      const matchLabel = m.type === 'final' || m.num === 0 ? 'FINAL' : 'Match ' + m.num;
     
      html += `<tr>
        <td>${matchLabel}</td>
        <td>${team1.icon} ${team1.name}</td>
        <td><span class="vs-badge">VS</span></td>
        <td>${team2.icon} ${team2.name}</td>
        <td>${score}</td>
      </tr>`;
    });
  }
 
  if(!html) html = '<tr><td colspan="5" class="no-matches">No matches</td></tr>';
  tbody.innerHTML = html;
 
  // Check for winner if Day 4 (Final)
  if(d === 4){
    await checkAndDisplayWinner();
  }
}

// ================== Check and Display Winner ==================
async function checkAndDisplayWinner(){
  const winnerAnnouncement = document.getElementById('winnerAnnouncement');
  const winnerTeamDisplay = document.getElementById('winnerTeamDisplay');
 
  if(!winnerAnnouncement || !winnerTeamDisplay) return;
 
  // Get final match
  const { data: finalMatch, error } = await supabase
    .from('matches')
    .select('*')
    .eq('type', 'final')
    .eq('day', 4)
    .maybeSingle();
 
  if(error){
    console.error('Error checking final match:', error);
    winnerAnnouncement.style.display = 'none';
    return;
  }
 
  // Check if final is completed (has scores and real teams)
  if(finalMatch &&
     finalMatch.s1 !== null && finalMatch.s1 !== undefined &&
     finalMatch.s2 !== null && finalMatch.s2 !== undefined &&
     finalMatch.t1 !== 'Top 1 team' && finalMatch.t2 !== 'Top 2 team'){
   
    // Determine winner
    let winnerName = '';
    if(finalMatch.s1 > finalMatch.s2){
      winnerName = finalMatch.t1;
    } else if(finalMatch.s2 > finalMatch.s1){
      winnerName = finalMatch.t2;
    }
   
    if(winnerName){
      // Get team icon
      const team = teamsMap[winnerName] || {name: winnerName, icon: 'üè∏'};
      winnerTeamDisplay.innerHTML = `${team.icon} ${team.name}`;
      winnerAnnouncement.style.display = 'block';
    } else {
      winnerAnnouncement.style.display = 'none';
    }
  } else {
    winnerAnnouncement.style.display = 'none';
  }
}

// ================== Rankings - Real-time from Supabase ==================
let rankingsChannel = null;
let rankingsPollInterval = null;

window.loadRankings = async function(){
  const rBody = document.getElementById('rankingBody');
 
  // Try to subscribe to real-time changes
  try {
    rankingsChannel = supabase
      .channel('rankings-changes')
      .on('postgres_changes',
        { event: '*', schema: 'public', table: 'rankings' },
        (payload) => {
          console.log('Realtime update received:', payload);
          displayRankings();
        }
      )
      .subscribe((status) => {
        console.log('Realtime subscription status:', status);
        // If subscription fails, use polling as fallback
        if(status === 'SUBSCRIBED'){
          // Clear any existing polling
          if(rankingsPollInterval) clearInterval(rankingsPollInterval);
        } else {
          // Fallback to polling every 2 seconds
          if(!rankingsPollInterval){
            rankingsPollInterval = setInterval(() => {
              displayRankings();
            }, 2000);
          }
        }
      });
  } catch(error) {
    console.log('Realtime not available, using polling:', error);
    // Fallback to polling
    if(!rankingsPollInterval){
      rankingsPollInterval = setInterval(() => {
        displayRankings();
      }, 2000);
    }
  }
 
  // Initial load
  await displayRankings();
}

async function displayRankings(){
  const rBody = document.getElementById('rankingBody');
 
  const { data, error } = await supabase
    .from('rankings')
    .select('*');
 
  if(error){
    console.error('Error loading rankings:', error);
    rBody.innerHTML = '<tr><td colspan="7" class="no-matches">Error loading rankings</td></tr>';
    return;
  }
 
  let html = '';
  if(!data || data.length === 0){
    html = '<tr><td colspan="7" class="no-matches">No teams registered yet</td></tr>';
  } else {
    // Sort by points first, then by point difference if points are equal
    const sortedData = [...data].sort((a, b) => {
      // First sort by points (descending)
      if(b.pts !== a.pts) return b.pts - a.pts;
      // If points are equal, sort by point difference (descending)
      if(b.pd !== a.pd) return (b.pd || 0) - (a.pd || 0);
      // If both are equal, sort by wins (descending)
      if(b.w !== a.w) return b.w - a.w;
      // Finally, sort alphabetically by name
      return a.name.localeCompare(b.name);
    });
   
    sortedData.forEach((t, i) => {
      const c = i === 0 ? 'rank-1' : i === 1 ? 'rank-2' : i === 2 ? 'rank-3' : 'rank-other';
      const pd = t.pd || 0;
      const pdDisplay = pd > 0 ? `+${pd}` : pd.toString();
      html += `<tr>
        <td><span class="rank-badge ${c}">${i + 1}</span></td>
        <td>${t.icon} ${t.name}</td>
        <td>${t.p || 0}</td>
        <td>${t.w || 0}</td>
        <td>${t.l || 0}</td>
        <td style="color:${pd > 0 ? '#4CAF50' : pd < 0 ? '#f44336' : '#999'};">${pdDisplay}</td>
        <td>${t.pts || 0}</td>
      </tr>`;
    });
  }
  rBody.innerHTML = html;
 
  // Auto-update final match when rankings are displayed
  await updateFinalMatch();
}

// ================== Calculate and Update Rankings ==================
async function calculateAndUpdateRankings(){
  console.log('Starting ranking calculation...');
 
  // Get all league matches with scores
  const { data: matches, error: matchesError } = await supabase
    .from('matches')
    .select('*')
    .eq('type', 'league')
    .not('s1', 'is', null)
    .not('s2', 'is', null);
 
  if(matchesError){
    console.error('Error loading matches:', matchesError);
    notify('Error loading matches: ' + matchesError.message, 'error');
    return;
  }
 
  console.log('Matches with scores:', matches);
 
  // Get all teams
  const { data: teams, error: teamsError } = await supabase.from('teams').select('*');
 
  if(teamsError){
    console.error('Error loading teams:', teamsError);
    notify('Error loading teams: ' + teamsError.message, 'error');
    return;
  }
 
  if(!teams || teams.length === 0){
    console.error('No teams found');
    return;
  }
 
  console.log('Teams loaded:', teams);
 
  // Initialize rankings
  const rankings = {};
  teams.forEach(team => {
    rankings[team.name] = {
      name: team.name,
      icon: team.icon,
      p: 0,
      w: 0,
      l: 0,
      pd: 0,  // Point difference (score_for - score_against)
      pts: 0
    };
  });
 
  // Process matches (only those with valid scores)
  if(matches && matches.length > 0){
    matches.forEach(m => {
      // Double-check that scores are valid (not null/undefined)
      if(m.s1 === null || m.s1 === undefined || m.s2 === null || m.s2 === undefined){
        console.log('Skipping match with null scores:', m.t1, 'vs', m.t2);
        return; // Skip this match
      }
     
      console.log('Processing match:', m.t1, 'vs', m.t2, 'Score:', m.s1, '-', m.s2);
      if(rankings[m.t1] && rankings[m.t2]){
        rankings[m.t1].p++;
        rankings[m.t2].p++;
       
        // Calculate point difference (score_for - score_against)
        const pd1 = m.s1 - m.s2;  // Team 1's point difference in this match
        const pd2 = m.s2 - m.s1;  // Team 2's point difference in this match
       
        rankings[m.t1].pd += pd1;
        rankings[m.t2].pd += pd2;
       
        if(m.s1 > m.s2){
          rankings[m.t1].w++;
          rankings[m.t1].pts += 2;
          rankings[m.t2].l++;
        } else if(m.s2 > m.s1){
          rankings[m.t2].w++;
          rankings[m.t2].pts += 2;
          rankings[m.t1].l++;
        }
        // Note: If scores are equal, both teams get a match played but no win/loss/points
      } else {
        console.warn('Team not found in rankings:', m.t1, 'or', m.t2);
      }
    });
  } else {
    console.log('No matches with scores found');
  }
 
  console.log('Calculated rankings:', rankings);
 
  // Update rankings in Supabase
  const updatePromises = [];
  for(const [teamName, stats] of Object.entries(rankings)){
    updatePromises.push(
      supabase
        .from('rankings')
        .upsert({
          name: teamName,
          icon: stats.icon,
          p: stats.p,
          w: stats.w,
          l: stats.l,
          pd: stats.pd,
          pts: stats.pts
        }, { onConflict: 'name' })
    );
  }
 
  const results = await Promise.all(updatePromises);
  results.forEach((result, index) => {
    if(result.error) {
      console.error('Error updating ranking for:', Object.keys(rankings)[index], result.error);
    } else {
      console.log('Updated ranking for:', Object.keys(rankings)[index]);
    }
  });
 
  console.log('Rankings calculation complete');
 
  // Refresh the ranking display immediately
  await displayRankings();
 
  // Auto-update final match with top 2 teams
  await updateFinalMatch();
}

// ================== Auto-Update Final Match ==================
async function updateFinalMatch(){
  // First, check if all league matches (days 1-3) have been completed
  const { data: allLeagueMatches, error: matchesError } = await supabase
    .from('matches')
    .select('*')
    .eq('type', 'league')
    .in('day', [1, 2, 3]);
 
  if(matchesError){
    console.error('Error checking league matches:', matchesError);
    return;
  }
 
  if(!allLeagueMatches || allLeagueMatches.length === 0){
    console.log('No league matches found, cannot determine final teams yet');
    return;
  }
 
  // Check if all league matches have scores
  const incompleteMatches = allLeagueMatches.filter(m =>
    m.s1 === null || m.s1 === undefined || m.s2 === null || m.s2 === undefined
  );
 
  if(incompleteMatches.length > 0){
    console.log(`Not all league matches completed. ${incompleteMatches.length} match(es) still pending. Final teams will be determined after all league matches are played.`);
   
    // Check if final match exists
    const { data: existingFinal } = await supabase
      .from('matches')
      .select('*')
      .eq('day', 4)
      .eq('type', 'final')
      .maybeSingle();
   
    // If final match doesn't exist, create it with placeholder teams
    if(!existingFinal){
      const { error: createError } = await supabase
        .from('matches')
        .insert([{
          day: 4,
          num: 0,
          t1: 'Top 1 team',
          t2: 'Top 2 team',
          type: 'final',
          s1: null,
          s2: null
        }]);
     
      if(createError){
        console.error('Error creating placeholder final match:', createError);
      } else {
        console.log('Created final match with placeholder teams');
        // Refresh fixtures if on final tab
        if(document.getElementById('day-4') && document.getElementById('day-4').classList.contains('active')){
          loadDay(4);
        }
      }
      return;
    }
   
    // If final match exists but has real teams (not placeholders), reset to placeholder
    if(existingFinal.t1 !== 'Top 1 team' && existingFinal.t2 !== 'Top 2 team' &&
       existingFinal.s1 === null && existingFinal.s2 === null){
      await supabase
        .from('matches')
        .update({
          t1: 'Top 1 team',
          t2: 'Top 2 team'
        })
        .eq('id', existingFinal.id);
     
      console.log('Reset final match to placeholder teams (league not complete)');
      // Refresh fixtures if on final tab
      if(document.getElementById('day-4') && document.getElementById('day-4').classList.contains('active')){
        loadDay(4);
      }
    }
   
    return;
  }
 
  console.log('All league matches completed! Determining final teams...');
 
  // Get top 2 teams from rankings
  const { data: rankings, error: rankingsError } = await supabase
    .from('rankings')
    .select('*')
    .order('pts', { ascending: false })
    .order('w', { ascending: false })
    .limit(2);
 
  if(rankingsError){
    console.error('Error loading rankings for final:', rankingsError);
    return;
  }
 
  if(!rankings || rankings.length < 2){
    console.log('Not enough teams in rankings for final match');
    return;
  }
 
  const topTeam1 = rankings[0].name;
  const topTeam2 = rankings[1].name;
 
  console.log('Top 2 teams for final:', topTeam1, 'vs', topTeam2);
 
  // Find or create final match
  const { data: existingFinal, error: findError } = await supabase
    .from('matches')
    .select('*')
    .eq('day', 4)
    .eq('type', 'final')
    .maybeSingle();
 
  if(findError && findError.code !== 'PGRST116'){ // PGRST116 = no rows returned
    console.error('Error finding final match:', findError);
    return;
  }
 
  if(existingFinal){
    // Don't update if match has already been played (has scores)
    if(existingFinal.s1 !== null && existingFinal.s1 !== undefined &&
       existingFinal.s2 !== null && existingFinal.s2 !== undefined){
      console.log('Final match already played, not updating teams');
      return;
    }
   
    // Update existing final match (only if teams changed)
    if(existingFinal.t1 !== topTeam1 || existingFinal.t2 !== topTeam2){
      const { error: updateError } = await supabase
        .from('matches')
        .update({
          t1: topTeam1,
          t2: topTeam2
        })
        .eq('id', existingFinal.id);
     
      if(updateError){
        console.error('Error updating final match:', updateError);
      } else {
        console.log('Final match updated with top 2 teams');
        // Refresh fixtures if on final tab
        if(document.getElementById('day-4') && document.getElementById('day-4').classList.contains('active')){
          loadDay(4);
        }
      }
    } else {
      console.log('Final match teams already correct');
    }
  } else {
    // Create final match if it doesn't exist
    const { error: insertError } = await supabase
      .from('matches')
      .insert([{
        day: 4,
        num: 0,
        t1: topTeam1,
        t2: topTeam2,
        type: 'final',
        s1: null,
        s2: null
      }]);
   
    if(insertError){
      console.error('Error creating final match:', insertError);
    } else {
      console.log('Final match created with top 2 teams');
      // Refresh fixtures if on final tab
      if(document.getElementById('day-4') && document.getElementById('day-4').classList.contains('active')){
        loadDay(4);
      }
    }
  }
}

// ================== Matches Management ==================
window.loadMatches = async function(){
  const matchScoresDiv = document.getElementById('matchScores');
  matchScoresDiv.innerHTML = '';
 
  // Load league matches
  const { data: leagueMatches, error: leagueError } = await supabase
    .from('matches')
    .select('*')
    .eq('type', 'league')
    .order('day', { ascending: true })
    .order('num', { ascending: true });
 
  if(leagueError){
    console.error('Error loading league matches:', leagueError);
  } else if(leagueMatches){
    leagueMatches.forEach(m => {
      const team1 = teamsMap[m.t1] || {name: m.t1, icon: 'üè∏'};
      const team2 = teamsMap[m.t2] || {name: m.t2, icon: 'üè∏'};
      const s1 = m.s1 !== null && m.s1 !== undefined ? m.s1 : '';
      const s2 = m.s2 !== null && m.s2 !== undefined ? m.s2 : '';
      const matchLabel = 'Match ' + m.num;
      matchScoresDiv.innerHTML += `<div style="margin-bottom:15px;padding:15px;background:rgba(40,40,40,0.5);border-radius:8px;">
        <strong>${matchLabel} (Day ${m.day}):</strong><br>
        ${team1.icon} ${team1.name}
        <input class="score-input" id="s1_${m.id}" value="${s1}" placeholder="0"> -
        <input class="score-input" id="s2_${m.id}" value="${s2}" placeholder="0">
        ${team2.icon} ${team2.name}
        <button class="btn btn-success" onclick="updateScore(${m.id})" style="margin-left:10px;">Update</button>
        <button class="btn-reset" onclick="resetScore(${m.id})">Reset</button>
      </div>`;
    });
  }
 
  // Load final match separately
  const { data: finalMatch, error: finalError } = await supabase
    .from('matches')
    .select('*')
    .eq('type', 'final')
    .eq('day', 4)
    .maybeSingle();
 
  if(finalError && finalError.code !== 'PGRST116'){
    console.error('Error loading final match:', finalError);
  } else if(finalMatch){
    const team1 = teamsMap[finalMatch.t1] || {name: finalMatch.t1, icon: 'üè∏'};
    const team2 = teamsMap[finalMatch.t2] || {name: finalMatch.t2, icon: 'üè∏'};
    const s1 = finalMatch.s1 !== null && finalMatch.s1 !== undefined ? finalMatch.s1 : '';
    const s2 = finalMatch.s2 !== null && finalMatch.s2 !== undefined ? finalMatch.s2 : '';
   
    // Check if final has real teams (not placeholder)
    const hasRealTeams = finalMatch.t1 !== 'Top 1 team' && finalMatch.t2 !== 'Top 2 team';
   
    let buttonsHtml = '';
    if(hasRealTeams){
      buttonsHtml = `<button class="btn btn-success" onclick="updateScore(${finalMatch.id})" style="margin-left:10px;">Update Final Score</button>
        <button class="btn-reset" onclick="resetScore(${finalMatch.id})">Reset</button>`;
    } else {
      buttonsHtml = '<span style="color:#999;margin-left:10px;font-style:italic;">Final teams will be determined after all league matches are completed</span>';
    }
   
    matchScoresDiv.innerHTML += `<div style="margin-bottom:15px;padding:15px;background:linear-gradient(135deg,rgba(196,30,58,0.3) 0%,rgba(139,0,0,0.3) 100%);border-radius:8px;border:2px solid #c41e3a;">
      <strong style="color:#c41e3a;font-size:18px;">üèÜ FINAL (Day 4):</strong><br>
      ${team1.icon} ${team1.name}
      <input class="score-input" id="s1_${finalMatch.id}" value="${s1}" placeholder="0"> -
      <input class="score-input" id="s2_${finalMatch.id}" value="${s2}" placeholder="0">
      ${team2.icon} ${team2.name}
      ${buttonsHtml}
    </div>`;
  }
}

window.updateScore = async function(matchId){
  if(!isAdmin) {
    notify('Not authorized', 'error');
    return;
  }
 
  const s1Input = document.getElementById('s1_' + matchId);
  const s2Input = document.getElementById('s2_' + matchId);
 
  if(!s1Input || !s2Input){
    notify('Score inputs not found', 'error');
    console.error('Inputs not found for matchId:', matchId);
    return;
  }
 
  const s1 = parseInt(s1Input.value) || 0;
  const s2 = parseInt(s2Input.value) || 0;
 
  console.log('Updating score for match:', matchId, 'Score:', s1, '-', s2);
 
  const { data, error } = await supabase
    .from('matches')
    .update({ s1, s2 })
    .eq('id', matchId)
    .select();
 
  if(error){
    notify('Error updating score: ' + error.message, 'error');
    console.error('Update error:', error);
    return;
  }
 
  console.log('Score updated successfully:', data);
 
  // Check if this is a final match that was just completed
  if(data && data.length > 0){
    const match = data[0];
    if(match.type === 'final' && match.s1 !== null && match.s2 !== null &&
       match.t1 !== 'Top 1 team' && match.t2 !== 'Top 2 team'){
      // Determine winner
      let winnerName = '';
      if(match.s1 > match.s2){
        winnerName = match.t1;
      } else if(match.s2 > match.s1){
        winnerName = match.t2;
      }
     
      if(winnerName){
        // Show winner panel
        showWinnerPanel(winnerName);
        notify('Final match completed! üèÜ');
      }
    }
  }
 
  notify('Score updated - Ranking will update automatically!');
 
  // Recalculate rankings immediately
  console.log('Recalculating rankings...');
  await calculateAndUpdateRankings();
 
  // Also refresh the ranking display
  await displayRankings();
 
  // Refresh fixtures to show updated scores
  await loadFixtures();
 
  // Check and display winner if final was completed
  if(data && data.length > 0 && data[0].type === 'final'){
    await checkAndDisplayWinner();
  }
 
  // Reload matches section to show updated scores
  loadMatches();
}

window.resetScore = async function(matchId){
  if(!isAdmin) {
    notify('Not authorized', 'error');
    return;
  }
 
  // Confirm reset
  if(!confirm('Are you sure you want to reset this score? This will remove the scores and recalculate rankings (matches played, wins, losses, and points will decrease).')){
    return;
  }
 
  console.log('Resetting score for match:', matchId);
 
  // Clear the input fields first (for immediate UI feedback)
  const s1Input = document.getElementById('s1_' + matchId);
  const s2Input = document.getElementById('s2_' + matchId);
  if(s1Input) s1Input.value = '';
  if(s2Input) s2Input.value = '';
 
  // Update database
  const { data, error } = await supabase
    .from('matches')
    .update({ s1: null, s2: null })
    .eq('id', matchId)
    .select();
 
  if(error){
    notify('Error resetting score: ' + error.message, 'error');
    console.error('Reset error:', error);
    // Reload matches to restore original values
    loadMatches();
    return;
  }
 
  console.log('Score reset successfully in database:', data);
  notify('Score reset - Recalculating rankings...');
 
  // Wait a moment to ensure database update is committed
  await new Promise(resolve => setTimeout(resolve, 100));
 
  // Recalculate rankings immediately (this will exclude the reset match)
  console.log('Recalculating rankings after reset (match will be excluded)...');
  await calculateAndUpdateRankings();
 
  // Refresh the ranking display
  await displayRankings();
 
  // Refresh fixtures to show updated scores
  loadFixtures();
 
  // Reload matches section to show updated scores
  loadMatches();
 
  notify('Score reset complete - Rankings updated!', 'success');
}

// ================== All Reset Function ==================
window.resetAllData = async function(){
  if(!isAdmin) {
    notify('Not authorized', 'error');
    return;
  }
 
  // Double confirmation for safety
  if(!confirm('‚ö†Ô∏è WARNING: This will reset ALL matches, scores, and rankings!\n\nTeams will be preserved, but all match data will be cleared.\n\nAre you absolutely sure you want to proceed?')){
    return;
  }
 
  if(!confirm('This action cannot be undone. Are you really sure?')){
    return;
  }
 
  notify('Resetting all data...', 'success');
 
  try {
    // Get all matches first, then update them individually
    const { data: allMatches, error: fetchError } = await supabase
      .from('matches')
      .select('id');
   
    if(fetchError){
      console.error('Error fetching matches:', fetchError);
      notify('Error fetching matches: ' + fetchError.message, 'error');
      return;
    }
   
    // Reset all match scores to null
    if(allMatches && allMatches.length > 0){
      const updatePromises = allMatches.map(match =>
        supabase
          .from('matches')
          .update({ s1: null, s2: null })
          .eq('id', match.id)
      );
     
      const results = await Promise.all(updatePromises);
      const matchesError = results.find(r => r.error);
     
      if(matchesError){
        console.error('Error resetting match scores:', matchesError.error);
        notify('Error resetting match scores: ' + matchesError.error.message, 'error');
        return;
      }
    }
   
    // Reset all rankings to zero
    const { data: teams, error: teamsError } = await supabase
      .from('teams')
      .select('*');
   
    if(teamsError){
      console.error('Error loading teams:', teamsError);
      notify('Error loading teams: ' + teamsError.message, 'error');
      return;
    }
   
    if(teams && teams.length > 0){
      const resetPromises = teams.map(team =>
        supabase
          .from('rankings')
          .upsert({
            name: team.name,
            icon: team.icon,
            p: 0,
            w: 0,
            l: 0,
            pd: 0,
            pts: 0
          }, { onConflict: 'name' })
      );
     
      await Promise.all(resetPromises);
    }
   
    // Reset final match teams to placeholder
    const { data: finalMatch } = await supabase
      .from('matches')
      .select('*')
      .eq('type', 'final')
      .eq('day', 4)
      .maybeSingle();
   
    if(finalMatch){
      await supabase
        .from('matches')
        .update({
          t1: 'Top 1 team',
          t2: 'Top 2 team',
          s1: null,
          s2: null
        })
        .eq('id', finalMatch.id);
    }
   
    // Close winner panel if open
    closeWinnerPanel();
   
    // Hide winner announcement
    const winnerAnnouncement = document.getElementById('winnerAnnouncement');
    if(winnerAnnouncement){
      winnerAnnouncement.style.display = 'none';
    }
   
    // Refresh all displays
    await loadFixtures();
    await loadMatches();
    await displayRankings();
   
    notify('All data reset successfully! New season ready to start! üéâ', 'success');
   
  } catch(error){
    console.error('Error in resetAllData:', error);
    notify('Error resetting data: ' + error.message, 'error');
  }
}

// ================== Team Management ==================
window.loadTeamsList = async function(){
  const teamsListDiv = document.getElementById('teamsList');
  if(!teamsListDiv) return;
 
  const { data: teams, error } = await supabase
    .from('teams')
    .select('*')
    .order('name', { ascending: true });
 
  if(error){
    console.error('Error loading teams:', error);
    teamsListDiv.innerHTML = '<p style="color:#c41e3a;">Error loading teams</p>';
    return;
  }
 
  if(!teams || teams.length === 0){
    teamsListDiv.innerHTML = '<p style="color:#999;">No teams found</p>';
    return;
  }
 
  let html = '<div style="display:grid;gap:15px;">';
  teams.forEach(team => {
    html += `<div style="padding:15px;background:rgba(40,40,40,0.5);border-radius:8px;display:flex;justify-content:space-between;align-items:center;">
      <div>
        <strong style="color:#ddd;font-size:18px;">${team.icon} ${team.name}</strong>
      </div>
      <button class="delete-btn" onclick="deleteTeam(${team.id}, '${team.name}')" style="padding:8px 15px;">Delete</button>
    </div>`;
  });
  html += '</div>';
  teamsListDiv.innerHTML = html;
}

window.addNewTeam = async function(){
  if(!isAdmin) {
    notify('Not authorized', 'error');
    return;
  }
 
  const name = document.getElementById('newTeamName').value.trim();
  const icon = document.getElementById('newTeamIcon').value.trim();
 
  if(!name || !icon){
    notify('Please fill in all fields', 'error');
    return;
  }
 
  // Check if team already exists
  const { data: existing } = await supabase
    .from('teams')
    .select('*')
    .eq('name', name)
    .single();
 
  if(existing){
    notify('Team with this name already exists!', 'error');
    return;
  }
 
  const { data, error } = await supabase
    .from('teams')
    .insert([{ name, icon }])
    .select();
 
  if(error){
    notify('Error adding team: ' + error.message, 'error');
    console.error('Add team error:', error);
    return;
  }
 
  notify('Team added successfully!', 'success');
 
  // Clear form
  document.getElementById('newTeamName').value = '';
  document.getElementById('newTeamIcon').value = '';
 
  // Reload teams list and map
  await loadTeamsMap();
  await loadTeamsList();
 
  // Add team to rankings with zero stats
  await supabase
    .from('rankings')
    .upsert({
      name: name,
      icon: icon,
      p: 0,
      w: 0,
      l: 0,
      pd: 0,
      pts: 0
    }, { onConflict: 'name' });
 
  // Update team dropdowns in add match form
  populateTeamDropdowns();
 
  // Refresh rankings display
  await displayRankings();
}

window.deleteTeam = async function(teamId, teamName){
  if(!isAdmin) {
    notify('Not authorized', 'error');
    return;
  }
 
  if(!confirm(`Are you sure you want to delete "${teamName}"? This will also delete all matches involving this team and update rankings.`)){
    return;
  }
 
  // First, delete all matches involving this team
  const { error: matchesError } = await supabase
    .from('matches')
    .delete()
    .or(`t1.eq.${teamName},t2.eq.${teamName}`);
 
  if(matchesError){
    console.error('Error deleting matches:', matchesError);
  }
 
  // Delete rankings for this team
  const { error: rankingsError } = await supabase
    .from('rankings')
    .delete()
    .eq('name', teamName);
 
  if(rankingsError){
    console.error('Error deleting rankings:', rankingsError);
  }
 
  // Delete the team
  const { error } = await supabase
    .from('teams')
    .delete()
    .eq('id', teamId);
 
  if(error){
    notify('Error deleting team: ' + error.message, 'error');
    console.error('Delete team error:', error);
    return;
  }
 
  notify('Team deleted successfully!', 'success');
 
  // Reload everything
  await loadTeamsMap();
  await loadTeamsList();
  await loadFixtures();
  await loadMatches();
  await calculateAndUpdateRankings();
  await displayRankings();
  populateTeamDropdowns();
}

// ================== Match/Fixture Management ==================
window.loadMatchesList = async function(){
  const matchesListDiv = document.getElementById('matchesList');
  if(!matchesListDiv) return;
 
  const { data: matches, error } = await supabase
    .from('matches')
    .select('*')
    .order('day', { ascending: true })
    .order('num', { ascending: true });
 
  if(error){
    console.error('Error loading matches:', error);
    matchesListDiv.innerHTML = '<p style="color:#c41e3a;">Error loading matches</p>';
    return;
  }
 
  if(!matches || matches.length === 0){
    matchesListDiv.innerHTML = '<p style="color:#999;">No matches found</p>';
    return;
  }
 
  let html = '<div style="display:grid;gap:15px;">';
  matches.forEach(match => {
    const team1 = teamsMap[match.t1] || {name: match.t1, icon: 'üè∏'};
    const team2 = teamsMap[match.t2] || {name: match.t2, icon: 'üè∏'};
    const matchLabel = match.type === 'final' || match.num === 0 ? 'FINAL' : `Match ${match.num}`;
    const score = (match.s1 !== null && match.s2 !== null) ? `${match.s1} - ${match.s2}` : '- -';
   
    html += `<div style="padding:15px;background:rgba(40,40,40,0.5);border-radius:8px;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
        <div>
          <strong style="color:#c41e3a;">Day ${match.day} - ${matchLabel}</strong>
        </div>
        <button class="delete-btn" onclick="deleteMatch(${match.id})" style="padding:8px 15px;">Delete</button>
      </div>
      <div style="color:#ddd;">
        ${team1.icon} ${team1.name} <span style="margin:0 10px;">VS</span> ${team2.icon} ${team2.name}
        <span style="margin-left:15px;color:#999;">Score: ${score}</span>
      </div>
    </div>`;
  });
  html += '</div>';
  matchesListDiv.innerHTML = html;
}

function populateTeamDropdowns(){
  const t1Select = document.getElementById('newMatchT1');
  const t2Select = document.getElementById('newMatchT2');
 
  if(!t1Select || !t2Select) return;
 
  const teamNames = Object.keys(teamsMap).sort();
 
  t1Select.innerHTML = '<option value="">Select Team 1</option>';
  t2Select.innerHTML = '<option value="">Select Team 2</option>';
 
  teamNames.forEach(teamName => {
    const team = teamsMap[teamName];
    const option1 = `<option value="${teamName}">${team.icon} ${team.name}</option>`;
    const option2 = `<option value="${teamName}">${team.icon} ${team.name}</option>`;
    t1Select.innerHTML += option1;
    t2Select.innerHTML += option2;
  });
}

window.addNewMatch = async function(){
  if(!isAdmin) {
    notify('Not authorized', 'error');
    return;
  }
 
  const day = parseInt(document.getElementById('newMatchDay').value);
  const num = parseInt(document.getElementById('newMatchNum').value);
  const t1 = document.getElementById('newMatchT1').value;
  const t2 = document.getElementById('newMatchT2').value;
  const type = document.getElementById('newMatchType').value;
 
  if(!t1 || !t2){
    notify('Please select both teams', 'error');
    return;
  }
 
  if(t1 === t2){
    notify('Team 1 and Team 2 cannot be the same!', 'error');
    return;
  }
 
  // Check if match already exists
  const { data: existing } = await supabase
    .from('matches')
    .select('*')
    .eq('day', day)
    .eq('num', num)
    .eq('t1', t1)
    .eq('t2', t2)
    .single();
 
  if(existing){
    notify('This match already exists!', 'error');
    return;
  }
 
  const { data, error } = await supabase
    .from('matches')
    .insert([{ day, num, t1, t2, type, s1: null, s2: null }])
    .select();
 
  if(error){
    notify('Error adding match: ' + error.message, 'error');
    console.error('Add match error:', error);
    return;
  }
 
  notify('Match added successfully!', 'success');
 
  // Clear form
  document.getElementById('newMatchNum').value = '';
  document.getElementById('newMatchT1').value = '';
  document.getElementById('newMatchT2').value = '';
 
  // Reload matches list and fixtures
  await loadMatchesList();
  await loadFixtures();
  await loadMatches();
}

window.deleteMatch = async function(matchId){
  if(!isAdmin) {
    notify('Not authorized', 'error');
    return;
  }
 
  if(!confirm('Are you sure you want to delete this match? This will also remove its score from rankings.')){
    return;
  }
 
  const { error } = await supabase
    .from('matches')
    .delete()
    .eq('id', matchId);
 
  if(error){
    notify('Error deleting match: ' + error.message, 'error');
    console.error('Delete match error:', error);
    return;
  }
 
  notify('Match deleted successfully!', 'success');
 
  // Recalculate rankings
  await calculateAndUpdateRankings();
  await displayRankings();
 
  // Reload everything
  await loadMatchesList();
  await loadFixtures();
  await loadMatches();
}

// ================== Initialize App ==================
window.addEventListener('load', async () => {
  await loadTeamsMap();
 
  // Set up real-time listener for matches (to recalculate rankings)
  try {
    supabase
      .channel('matches-changes')
      .on('postgres_changes',
        { event: 'UPDATE', schema: 'public', table: 'matches' },
        (payload) => {
          console.log('Match updated, recalculating rankings:', payload);
          calculateAndUpdateRankings();
        }
      )
      .subscribe((status) => {
        console.log('Matches subscription status:', status);
        // If realtime doesn't work, we'll recalculate on manual refresh
      });
  } catch(error) {
    console.log('Realtime for matches not available:', error);
  }
 
  // Load rankings and calculate if needed
  await loadRankings();
 
  // Always calculate rankings on load to ensure they're up to date
  await calculateAndUpdateRankings();
 
  goToSection('fixture');
});
</script>
</body>
</html>
